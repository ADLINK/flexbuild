diff --git a/arch/arm64/boot/dts/freescale/Makefile b/arch/arm64/boot/dts/freescale/Makefile
index 025a2a8b0739..c5439fe2a888 100644
--- a/arch/arm64/boot/dts/freescale/Makefile
+++ b/arch/arm64/boot/dts/freescale/Makefile
@@ -113,92 +113,8 @@ dtb-$(CONFIG_ARCH_MXC) += imx8mn-ddr3l-evk-ak5558.dtb imx8mn-ddr4-evk-ak5558.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mn-ab2.dtb imx8mn-ddr3l-ab2.dtb imx8mn-ddr4-ab2.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mn-evk-iqaudio-dacplus.dtb imx8mn-evk-iqaudio-dacpro.dtb imx8mn-evk-hifiberry-dacplus.dtb \
 			  imx8mn-evk-hifiberry-dac2.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk.dtb imx8mp-evk-rm67191.dtb imx8mp-evk-it6263-lvds-dual-channel.dtb \
-			  imx8mp-evk-pcie-ep.dtb  imx8mp-evk-rpmsg.dtb imx8mp-evk-ecspi-slave.dtb \
-			  imx8mp-evk-jdi-wuxga-lvds-panel.dtb imx8mp-evk-flexcan2.dtb \
-			  imx8mp-evk-root.dtb imx8mp-evk-inmate.dtb imx8mp-evk-ov2775.dtb \
-			  imx8mp-evk-ov2775-ov5640.dtb imx8mp-evk-basler-ov5640.dtb imx8mp-evk-basler.dtb \
-			  imx8mp-evk-basler-ov2775.dtb imx8mp-evk-dual-basler.dtb \
-			  imx8mp-evk-dual-ov2775.dtb imx8mp-evk-spdif-lb.dtb imx8mp-evk-dsp.dtb \
-			  imx8mp-evk-sof-wm8960.dtb imx8mp-evk-sof-pdm.dtb \
-			  imx8mp-evk-os08a20-ov5640.dtb imx8mp-evk-os08a20.dtb \
-			  imx8mp-evk-dual-os08a20.dtb \
-			  imx8mp-evk-iqaudio-dacplus.dtb imx8mp-evk-iqaudio-dacpro.dtb imx8mp-evk-hifiberry-dacplus.dtb \
-			  imx8mp-evk-hifiberry-dac2.dtb imx8mp-evk-hifiberry-dacplusadc.dtb \
-			  imx8mp-evk-usdhc1-m2.dtb imx8mp-evk-rm67199.dtb \
-			  imx8mp-evk-dpdk.dtb imx8mp-evk-8mic-swpdm.dtb imx8mp-evk-rpmsg-lpv.dtb imx8mp-evk-revA3-8mic-revE.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-msc-sm2s-ep1.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-phyboard-pollux-rdk.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-ab2.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-ddr4-evk.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-ndm.dtb
-
-imx8mp-evk-revb4-dtbs := imx8mp-evk.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-rm67191-dtbs := imx8mp-evk-rm67191.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-it6263-lvds-dual-channel-dtbs := imx8mp-evk-it6263-lvds-dual-channel.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-pcie-ep-dtbs := imx8mp-evk-pcie-ep.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-ecspi-slave-dtbs := imx8mp-evk-ecspi-slave.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-jdi-wuxga-lvds-panel-dtbs := imx8mp-evk-jdi-wuxga-lvds-panel.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-flexcan2-dtbs := imx8mp-evk-flexcan2.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-root-dtbs := imx8mp-evk-root.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-ov2775-dtbs := imx8mp-evk-ov2775.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-ov2775-ov5640-dtbs := imx8mp-evk-ov2775-ov5640.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-basler-ov5640-dtbs := imx8mp-evk-basler-ov5640.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-basler-dtbs := imx8mp-evk-basler.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-basler-ov2775-dtbs := imx8mp-evk-basler-ov2775.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-dual-basler-dtbs := imx8mp-evk-dual-basler.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-dual-ov2775-dtbs := imx8mp-evk-dual-ov2775.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-spdif-lb-dtbs := imx8mp-evk-spdif-lb.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-os08a20-ov5640-dtbs := imx8mp-evk-os08a20-ov5640.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-os08a20-dtbs := imx8mp-evk-os08a20.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-dual-os08a20-dtbs := imx8mp-evk-dual-os08a20.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-iqaudio-dacplus-dtbs := imx8mp-evk-iqaudio-dacplus.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-iqaudio-dacpro-dtbs := imx8mp-evk-iqaudio-dacpro.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-hifiberry-dacplus-dtbs := imx8mp-evk-hifiberry-dacplus.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-hifiberry-dac2-dtbs := imx8mp-evk-hifiberry-dac2.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-hifiberry-dacplusadc-dtbs := imx8mp-evk-hifiberry-dacplusadc.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-usdhc1-m2-dtbs := imx8mp-evk-usdhc1-m2.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-rm67199-dtbs := imx8mp-evk-rm67199.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-dpdk-dtbs := imx8mp-evk-dpdk.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-8mic-swpdm-dtbs := imx8mp-evk-8mic-swpdm.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-8mic-revE-dtbs := imx8mp-evk-revA3-8mic-revE.dtb imx8mp-evk-revb4.dtbo
-imx8mp-ddr4-evk-revb4-dtbs := imx8mp-ddr4-evk.dtb imx8mp-evk-revb4.dtbo
-imx8mp-evk-revb4-ndm-dtbs := imx8mp-evk-ndm.dtb imx8mp-evk-revb4.dtbo
-
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-rm67191.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-it6263-lvds-dual-channel.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-pcie-ep.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-ecspi-slave.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-jdi-wuxga-lvds-panel.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-flexcan2.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-root.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-ov2775.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-ov2775-ov5640.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-basler-ov5640.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-basler.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-basler-ov2775.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-dual-basler.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-dual-ov2775.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-spdif-lb.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-os08a20-ov5640.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-os08a20.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-dual-os08a20.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-iqaudio-dacplus.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-iqaudio-dacpro.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-hifiberry-dacplus.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-hifiberry-dac2.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-hifiberry-dacplusadc.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-usdhc1-m2.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-rm67199.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-dpdk.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-8mic-swpdm.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-8mic-revE.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-ddr4-evk-revb4.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-ndm.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-sof-wm8962.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-rpmsg.dtb
-dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk-revb4-rpmsg-lpv.dtb
+dtb-$(CONFIG_ARCH_MXC) += imx8mp-evk.dtb
+
 
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk.dtb imx8mq-evk-rpmsg.dtb
 dtb-$(CONFIG_ARCH_MXC) += imx8mq-evk.dtb imx8mq-evk-rpmsg.dtb imx8mq-evk-pcie1-m2.dtb imx8mq-evk-usd-wifi.dtb \
diff --git a/arch/arm64/boot/dts/freescale/imx8mp-evk.dts b/arch/arm64/boot/dts/freescale/imx8mp-evk.dts
index 966be019c433..599e7bf6370b 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp-evk.dts
+++ b/arch/arm64/boot/dts/freescale/imx8mp-evk.dts
@@ -8,9 +8,11 @@
 #include <dt-bindings/phy/phy-imx8-pcie.h>
 #include <dt-bindings/usb/pd.h>
 #include "imx8mp.dtsi"
+#include <dt-bindings/gpio/gpio.h>
+#include <dt-bindings/leds/common.h>
 
 / {
-	model = "NXP i.MX8MPlus EVK board";
+	model = "ADLINK Smart Panel - IMX8MP board";
 	compatible = "fsl,imx8mp-evk", "fsl,imx8mp";
 
 	chosen {
@@ -22,10 +24,10 @@ gpio-leds {
 		pinctrl-names = "default";
 		pinctrl-0 = <&pinctrl_gpio_led>;
 
-		status {
-			label = "yellow:status";
+		status_led {
+			label = "green:sys-status";
 			gpios = <&gpio3 16 GPIO_ACTIVE_HIGH>;
-			default-state = "on";
+			default-state = "on"; /* LED GREEN */
 		};
 	};
 
@@ -35,56 +37,54 @@ memory@40000000 {
 		      <0x1 0x00000000 0 0xc0000000>;
 	};
 
-	pcie0_refclk: pcie0-refclk {
+	/* 25MHz reference crystal */
+	ref25m: ref25xtal {
 		compatible = "fixed-clock";
 		#clock-cells = <0>;
-		clock-frequency = <100000000>;
+		clock-frequency = <25000000>;
 	};
 
-	reg_can1_stby: regulator-can1-stby {
+	reg_lvds_blpwr: regulator-lvds-pwr {
 		compatible = "regulator-fixed";
-		regulator-name = "can1-stby";
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_flexcan1_reg>;
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		gpio = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&pinctrl_reg_lvds_bl_pwr>;
+		regulator-name = "vdd";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpio = <&gpio3 20 GPIO_ACTIVE_HIGH>;
 		enable-active-high;
 	};
 
-	reg_can2_stby: regulator-can2-stby {
+	reg_usb0_pwr_en: regulator-usb0pwren {
 		compatible = "regulator-fixed";
-		regulator-name = "can2-stby";
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_flexcan2_reg>;
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		gpio = <&gpio4 27 GPIO_ACTIVE_HIGH>;
+		pinctrl-0 = <&pinctrl_usb0_pwr_en>;
+		regulator-name = "usb0-pwr-en";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpio = <&gpio1 14 GPIO_ACTIVE_HIGH>;
 		enable-active-high;
+		regulator-always-on;
 	};
 
-	reg_pcie0: regulator-pcie {
-		compatible = "regulator-fixed";
+	gpio-keys {
+		compatible = "gpio-keys";
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_pcie0_reg>;
-		regulator-name = "MPCIE_3V3";
-		regulator-min-microvolt = <3300000>;
-		regulator-max-microvolt = <3300000>;
-		gpio = <&gpio2 6 GPIO_ACTIVE_HIGH>;
-		enable-active-high;
-		regulator-always-on;
+		pinctrl-0 = <&pinctrl_gpio_keys>;
+
+		wakeup {
+			label = "Wake-Up";
+			gpios = <&gpio1 7 GPIO_ACTIVE_LOW>;
+			linux,code = <KEY_WAKEUP>;
+			debounce-interval = <10>;
+			wakeup-source;
+		};
 	};
 
-	reg_usb_vbus: regulator-vbus {
-		compatible = "regulator-fixed";
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_usb1_vbus>;
-		regulator-name = "USB_VBUS";
-		regulator-min-microvolt = <5000000>;
-		regulator-max-microvolt = <5000000>;
-		gpio = <&gpio1 14 GPIO_ACTIVE_HIGH>;
-		enable-active-high;
-		regulator-always-on;
+	extcon_usb0: extcon-usb-idvbus-grp0 {
+		compatible = "linux,extcon-usb-gpio";
+		id-gpio = <&gpio1 10 GPIO_ACTIVE_LOW>; /* GPIO1_IO10 */
+		// vbus-gpio = <&gpio1 15 GPIO_ACTIVE_LOW>; /* GPIO1_IO15 */
 	};
 
 	reg_usdhc2_vmmc: regulator-usdhc2 {
@@ -98,38 +98,38 @@ reg_usdhc2_vmmc: regulator-usdhc2 {
 		enable-active-high;
 	};
 
-	reg_audio_pwr: regulator-audio-pwr {
+	reg_ext_audio_3v: regulator-ext-audio-3v {
 		compatible = "regulator-fixed";
-		regulator-name = "audio-pwr";
+		regulator-name = "ext-audio-3V";
 		regulator-min-microvolt = <3300000>;
 		regulator-max-microvolt = <3300000>;
-		gpio = <&gpio4 29 GPIO_ACTIVE_HIGH>;
-		enable-active-high;
 		regulator-always-on;
 	};
 
-	bt_sco_codec: bt_sco_codec {
-		#sound-dai-cells = <1>;
-		compatible = "linux,bt-sco";
+	reg_ext_audio_1v8: regulator-ext-audio-1v8 {
+		compatible = "regulator-fixed";
+		regulator-name = "+V1.8";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		regulator-always-on;
 	};
 
-	sound-bt-sco {
-		compatible = "simple-audio-card";
-		simple-audio-card,name = "bt-sco-audio";
-		simple-audio-card,format = "dsp_a";
-		simple-audio-card,bitclock-inversion;
-		simple-audio-card,frame-master = <&btcpu>;
-		simple-audio-card,bitclock-master = <&btcpu>;
-
-		btcpu: simple-audio-card,cpu {
-			sound-dai = <&sai2>;
-			dai-tdm-slot-num = <2>;
-			dai-tdm-slot-width = <16>;
-		};
+	ex_audio_clk: sgtl5000_19M {
+		compatible = "fixed-clock";
+		#clock-cells = <0>;
+		clock-frequency = <19200000>; /* 19.2MHz */
+	};
 
-		simple-audio-card,codec {
-			sound-dai = <&bt_sco_codec 1>;
-		};
+	reg_speaker_amp: regulator-audio-amplifier {
+		compatible = "regulator-fixed";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_usbhub_spkamp>;
+		regulator-name = "speaker-amp";
+		regulator-min-microvolt = <1800000>;
+		regulator-max-microvolt = <1800000>;
+		gpios = <&gpio1 12 GPIO_ACTIVE_HIGH>;
+		enable-active-high;
+		regulator-always-on;
 	};
 
 	sound-hdmi {
@@ -147,52 +147,33 @@ sound-hdmi {
 		status = "okay";
 	};
 
-	sound-wm8960 {
-		compatible = "fsl,imx-audio-wm8960";
-		model = "wm8960-audio";
-		audio-cpu = <&sai3>;
-		audio-codec = <&codec>;
-		audio-asrc = <&easrc>;
-		hp-det-gpio = <&gpio4 28 0>;
+	sound {
+		compatible = "fsl,imx-audio-sgtl5000";
+		model = "audio-sgtl5000";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_hpdet>;
+		hp-det-gpio = <&gpio4 20 GPIO_ACTIVE_LOW>;
+		codec-master;
+		ssi-controller = <&sai3>;
+		audio-codec = <&sgtl5000>;
 		audio-routing =
-			"Headphone Jack", "HP_L",
-			"Headphone Jack", "HP_R",
-			"Ext Spk", "SPK_LP",
-			"Ext Spk", "SPK_LN",
-			"Ext Spk", "SPK_RP",
-			"Ext Spk", "SPK_RN",
-			"LINPUT1", "Mic Jack",
-			"LINPUT3", "Mic Jack",
-			"Mic Jack", "MICB";
-	};
-
-	sound-micfil {
-		compatible = "fsl,imx-audio-card";
-		model = "micfil-audio";
-		pri-dai-link {
-			link-name = "micfil hifi";
-			format = "i2s";
-			cpu {
-				sound-dai = <&micfil>;
-			};
-		};
-	};
-
-	sound-xcvr {
-		compatible = "fsl,imx-audio-card";
-		model = "imx-audio-xcvr";
-		pri-dai-link {
-			link-name = "XCVR PCM";
-			cpu {
-				sound-dai = <&xcvr>;
-			};
-		};
+			"MIC_IN", "Mic Jack",
+			"Mic Jack", "Mic Bias",
+			"Headphone Jack", "HP_OUT",
+			"Ext Spk", "LINE_OUT";
+		mux-int-port = <1>;
+		mux-ext-port = <3>;
+		status = "disabled";
 	};
 
 	lvds_backlight: lvds_backlight {
 		compatible = "pwm-backlight";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_reg_bl_en>;
+		enable-gpios = <&gpio1 0 GPIO_ACTIVE_HIGH>;
+		power-supply = <&reg_lvds_blpwr>;
 		pwms = <&pwm2 0 100000 0>;
-		status = "okay";
+		status = "disabled";
 
 		brightness-levels = < 0  1  2  3  4  5  6  7  8  9
 				     10 11 12 13 14 15 16 17 18 19
@@ -208,32 +189,25 @@ lvds_backlight: lvds_backlight {
 		default-brightness-level = <80>;
 	};
 
-	cbtl04gp {
-		compatible = "nxp,cbtl04gp";
+	lvds0_panel {
+		backlight = <&lvds_backlight>;
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_typec_mux>;
-		switch-gpios = <&gpio4 20 GPIO_ACTIVE_LOW>;
-		orientation-switch;
+		pinctrl-0 = <&pinctrl_reg_lvds_vdd>;
+		enable-gpios = <&gpio4 27 GPIO_ACTIVE_HIGH>;
+
+		data-mapping = "vesa-24";
+		status = "disabled";
 
 		port {
-			usb3_data_ss: endpoint {
-				remote-endpoint = <&typec_con_ss>;
+			panel_lvds_in: endpoint {
+				remote-endpoint = <&lvds_out>;
 			};
 		};
 	};
-};
 
-&flexspi {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_flexspi0>;
-	status = "okay";
-
-	flash@0 {
-		compatible = "jedec,spi-nor";
-		reg = <0>;
-		spi-max-frequency = <80000000>;
-		spi-tx-bus-width = <1>;
-		spi-rx-bus-width = <4>;
+	pwm-beeper {
+		compatible = "pwm-beeper";
+		pwms = <&pwm4 0 500000 0>;
 	};
 };
 
@@ -253,25 +227,80 @@ &A53_3 {
 	cpu-supply = <&buck2>;
 };
 
-&dsp {
-	status = "okay";
+&gpio1 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio1_hog>;
+
+	gpio-line-names =       \
+		"", "USB_MUX_SEL", "", "", "", "", "", "",  \
+		"", "", "", "", "", "", "", "",      \
+		"", "", "", "", "", "", "", "", \
+		"", "", "", "", "", "", "", "";
 };
 
-&pwm1 {
+&gpio4 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pwm1>;
-	status = "okay";
+	pinctrl-0 = <&pinctrl_gpio4_hog>;
+
+	gpio-line-names =	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"UART_MODE0", "UART_MODE1", "", "", "HWID_2", "HWID_3", "", "";
+/*
+	uart_mode0 {
+		gpios = <&gpio4 24 GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "UART_MODE0";
+	};
+
+	uart_mode1 {
+		gpios = <&gpio4 25 GPIO_ACTIVE_HIGH>;
+		output-low;
+		line-name = "UART_MODE1";
+	};
+
+	hwid_2 {
+		gpios = <&gpio4 28 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_2";
+	};
+
+	hwid_3 {
+		gpios = <&gpio4 29 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_3";
+	};
+*/
+};
+
+&gpio5 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_gpio5_hog>;
+
+	gpio-line-names =	\
+		"", "", "", "", "", "HWID_1", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "",	\
+		"", "", "", "", "", "", "", "";
+/*
+	hwid_1 {
+		gpios = <&gpio5 5 GPIO_ACTIVE_HIGH>;
+		input;
+		line-name = "HWID_1";
+	};
+*/
 };
 
 &pwm2 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pwm2>;
+	pinctrl-0 = <&pinctrl_bl_pwm2>;
 	status = "okay";
 };
 
 &pwm4 {
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pwm4>;
+	pinctrl-0 = <&pinctrl_buzz_pwm4>;
 	status = "okay";
 };
 
@@ -401,13 +430,16 @@ mdio {
 
 		ethphy1: ethernet-phy@1 {
 			compatible = "ethernet-phy-ieee802.3-c22";
-			reg = <1>;
+			reg = <2>;
 			eee-broken-1000t;
 			reset-gpios = <&gpio4 2 GPIO_ACTIVE_LOW>;
 			reset-assert-us = <10000>;
 			reset-deassert-us = <80000>;
 			realtek,aldps-enable;
 			realtek,clkout-disable;
+			interrupt-parent = <&gpio4>;
+			interrupts = <3 IRQ_TYPE_LEVEL_LOW>;
+			wakeup-source;
 		};
 	};
 };
@@ -415,18 +447,9 @@ ethphy1: ethernet-phy@1 {
 &flexcan1 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_flexcan1>;
-	xceiver-supply = <&reg_can1_stby>;
 	status = "okay";
 };
 
-&flexcan2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_flexcan2>;
-	xceiver-supply = <&reg_can2_stby>;
-	pinctrl-assert-gpios = <&pca6416 3 GPIO_ACTIVE_HIGH>;
-	status = "disabled";/* can2 pin conflict with pdm */
-};
-
 &i2c1 {
 	clock-frequency = <400000>;
 	pinctrl-names = "default";
@@ -530,192 +553,106 @@ ldo5: LDO5 {
 };
 
 &i2c2 {
-	clock-frequency = <400000>;
+	clock-frequency = <100000>;
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_i2c2>;
 	status = "okay";
+	
+	/* RTC: PCF85063A */
+	rtc: pcf85063a@51 {
+		compatible = "nxp,pcf85063a";
+		pinctrl-names = "default";
+		pinctrl-0 = <&pinctrl_rtc>;
+		quartz-load-femtofarads = <12500>;
+		reg = <0x51>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <22 IRQ_TYPE_EDGE_FALLING>;
+	};
 
-	adv_bridge: adv7535@3d {
-		compatible = "adi,adv7535";
-		reg = <0x3d>;
-		adi,addr-cec = <0x3b>;
-		adi,dsi-lanes = <4>;
-		status = "okay";
+	/* Comment to show an external PCIe CLK GEN: PI6CG33202C-ZDIEX */
+	/* pcieclk0: pi6cg33202@6a {
+		reg = <0x6a>;
+		compatible = "pi,6cg33202";
+	}; */
 
-		port {
-			adv7535_from_dsim: endpoint {
-				remote-endpoint = <&dsim_to_adv7535>;
-			};
-		};
-	};
+};
 
-	lvds_bridge: lvds-to-hdmi-bridge@4c {
-		compatible = "ite,it6263";
-		reg = <0x4c>;
-		reset-gpios = <&gpio1 10 GPIO_ACTIVE_LOW>;
+&i2c3 {
+	clock-frequency = <300000>;
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_i2c3>;
+	status = "okay";
 
-		port {
-			it6263_in: endpoint {
-				remote-endpoint = <&lvds_out>;
-			};
-		};
-	};
+	/* TPM: ST33HTPH2X32AHD5 */
+	tpm: st33htph77@2e {
+		compatible = "st,st33htpm-i2c";
+		reg = <0x2e>;
 
-	ov5640_0: ov5640_mipi@3c {
-		compatible = "ovti,ov5640";
-		reg = <0x3c>;
 		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_csi0_pwn>, <&pinctrl_csi0_rst>, <&pinctrl_csi_mclk>;
-		clocks = <&clk IMX8MP_CLK_IPP_DO_CLKO2>;
-		clock-names = "xclk";
-		assigned-clocks = <&clk IMX8MP_CLK_IPP_DO_CLKO2>;
-		assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
-		assigned-clock-rates = <24000000>;
-		csi_id = <0>;
-		powerdown-gpios = <&gpio2 11 GPIO_ACTIVE_HIGH>;
-		reset-gpios = <&gpio1 6 GPIO_ACTIVE_LOW>;
-		mclk = <24000000>;
-		mclk_source = <0>;
-		mipi_csi;
+		pinctrl-0 = <&pinctrl_tpm>;
+		interrupt-parent = <&gpio3>;
+		interrupts = <14 IRQ_TYPE_EDGE_FALLING>;
+		tpm-reset = <&gpio1 6 GPIO_ACTIVE_LOW>;
+		default-guard-time;
 		status = "okay";
+	};
 
-		port {
-			ov5640_mipi_0_ep: endpoint {
-				remote-endpoint = <&mipi_csi0_ep>;
-				data-lanes = <1 2>;
-				clock-lanes = <0>;
-			};
-		};
+	/* sgtl5000 audio codec */
+	sgtl5000: audio-codec@a {
+		compatible = "fsl,sgtl5000";
+		#sound-dai-cells = <0>;
+		reg = <0x0a>;
+		micbias-voltage-m-volts = <2250>;
+		VDDA-supply = <&reg_ext_audio_3v>;
+		VDDIO-supply = <&reg_ext_audio_1v8>;
+		VDDD-supply = <&reg_ext_audio_1v8>;
+		clocks = <&ex_audio_clk>;
+		status = "disabled";
 	};
 
-	ptn5110: tcpc@50 {
-		compatible = "nxp,ptn5110";
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_typec>;
+	eeprom@50 {
+		compatible = "atmel,24c256";
+		#address-cells = <1>;
+		#size-cells = <0>;
 		reg = <0x50>;
-		interrupt-parent = <&gpio4>;
-		interrupts = <19 8>;
-
-		port {
-			typec_dr_sw: endpoint {
-				remote-endpoint = <&usb3_drd_sw>;
-			};
-		};
-
-		usb_con: connector {
-			compatible = "usb-c-connector";
-			label = "USB-C";
-			power-role = "dual";
-			data-role = "dual";
-			try-power-role = "sink";
-			source-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)>;
-			sink-pdos = <PDO_FIXED(5000, 3000, PDO_FIXED_USB_COMM)
-				     PDO_VAR(5000, 20000, 3000)>;
-			op-sink-microwatt = <15000000>;
-			self-powered;
-
-			ports {
-				#address-cells = <1>;
-				#size-cells = <0>;
-
-				port@1 {
-					reg = <1>;
-					typec_con_ss: endpoint {
-						remote-endpoint = <&usb3_data_ss>;
-					};
-				};
-			};
-		};
+		pagesize = <64>;
+		size = <32768>;
+		address-width = <16>;
 	};
 };
 
-&i2c3 {
+&i2c6 {
 	clock-frequency = <400000>;
 	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c3>;
+	pinctrl-0 = <&pinctrl_i2c6>;
 	status = "okay";
 
-	pca6416: gpio@20 {
-		compatible = "ti,tca6416";
-		reg = <0x20>;
-		gpio-controller;
+	/* SX1509 */
+	sx1509: gpioext0@3f {
 		#gpio-cells = <2>;
-		interrupt-controller;
 		#interrupt-cells = <2>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_pca6416_int>;
-		interrupt-parent = <&gpio1>;
-		interrupts = <12 IRQ_TYPE_LEVEL_LOW>;
-		gpio-line-names = "EXT_PWREN1",
-			"EXT_PWREN2",
-			"CAN1/I2C5_SEL",
-			"PDM/CAN2_SEL",
-			"FAN_EN",
-			"PWR_MEAS_IO1",
-			"PWR_MEAS_IO2",
-			"EXP_P0_7",
-			"EXP_P1_0",
-			"EXP_P1_1",
-			"EXP_P1_2",
-			"EXP_P1_3",
-			"EXP_P1_4",
-			"EXP_P1_5",
-			"EXP_P1_6",
-			"EXP_P1_7";
-	};
-
-	codec: wm8960@1a {
-		compatible = "wlf,wm8960";
-		reg = <0x1a>;
-		clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1>;
-		clock-names = "mclk";
-		wlf,shared-lrclk;
-		wlf,hp-cfg = <3 2 3>;
-		wlf,gpio-cfg = <1 3>;
-		SPKVDD1-supply = <&reg_audio_pwr>;
-	};
-
-	ov5640_1: ov5640_mipi@3c {
-		compatible = "ovti,ov5640";
-		reg = <0x3c>;
-		pinctrl-names = "default";
-		pinctrl-0 = <&pinctrl_csi0_pwn>, <&pinctrl_csi0_rst>, <&pinctrl_csi_mclk>;
-		clocks = <&clk IMX8MP_CLK_IPP_DO_CLKO2>;
-		clock-names = "xclk";
-		assigned-clocks = <&clk IMX8MP_CLK_IPP_DO_CLKO2>;
-		assigned-clock-parents = <&clk IMX8MP_CLK_24M>;
-		assigned-clock-rates = <24000000>;
-		csi_id = <0>;
-		powerdown-gpios = <&gpio4 1 GPIO_ACTIVE_HIGH>;
-		reset-gpios = <&gpio4 0 GPIO_ACTIVE_LOW>;
-		mclk = <24000000>;
-		mclk_source = <0>;
-		mipi_csi;
-		status = "disabled";
+		compatible = "semtech,sx1509q";
+		reg = <0x3f>;
 
-		port {
-			ov5640_mipi_1_ep: endpoint {
-				remote-endpoint = <&mipi_csi1_ep>;
-				data-lanes = <1 2>;
-				clock-lanes = <0>;
-			};
-		};
-	};
-};
+		semtech,probe-reset;
+		gpio-controller;
+		interrupt-controller;
 
-/* I2C on expansion connector J22. */
-&i2c5 {
-	clock-frequency = <100000>; /* Lower clock speed for external bus. */
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_i2c5>;
-	status = "disabled"; /* can1 pins conflict with i2c5 */
-
-	/* GPIO 2 of PCA6416 is used to switch between CAN1 and I2C5 functions:
-	 *     LOW:  CAN1 (default, pull-down)
-	 *     HIGH: I2C5
-	 * You need to set it to high to enable I2C5 (for example, add gpio-hog
-	 * in pca6416 node).
-	 */
+		interrupt-parent = <&gpio3>;
+		interrupts = <21 IRQ_TYPE_EDGE_FALLING>;
+
+		gpio-line-names =	\
+		"DI0", "DI1", "DI2", "DI3", "DO0", "DO1", "DO2", "DO3",	\
+		"", "", "", "", "", "", "", "";
+
+		status = "okay";
+
+		/* GPIO Expander 0 Mapping :
+		 * 0: CN_DI0, 1: CN_DI1, 2: CN_DI2, 3: CN_DI3,
+		 * 4: CN_DO0, 5: CN_DO1, 6: CN_DO2, 7: CN_DO3
+		 * 8~15: N/A
+		 */
+	};
 };
 
 &irqsteer_hdmi {
@@ -739,11 +676,11 @@ &hdmiphy {
 };
 
 &lcdif1 {
-	status = "okay";
+	status = "disabled";
 };
 
 &lcdif2 {
-	status = "okay";
+	status = "disabled";
 };
 
 &lcdif3 {
@@ -754,16 +691,17 @@ &lcdif3 {
 };
 
 &ldb {
-	status = "okay";
+	/* fsl,dual-channel; */
 
 	lvds-channel@0 {
-		status = "okay";
+		fsl,data-mapping = "spwg";
+		fsl,data-width = <24>;
 
 		port@1 {
 			reg = <1>;
 
 			lvds_out: endpoint {
-				remote-endpoint = <&it6263_in>;
+				remote-endpoint = <&panel_lvds_in>;
 			};
 		};
 	};
@@ -774,59 +712,7 @@ &ldb_phy {
 };
 
 &mipi_dsi {
-	status = "okay";
-
-	port@1 {
-		dsim_to_adv7535: endpoint {
-			remote-endpoint = <&adv7535_from_dsim>;
-			attach-bridge;
-		};
-	};
-};
-
-&pcie_phy {
-	fsl,refclk-pad-mode = <IMX8_PCIE_REFCLK_PAD_INPUT>;
-	clocks = <&pcie0_refclk>;
-	clock-names = "ref";
-	status = "okay";
-};
-
-&pcie {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pcie0>;
-	reset-gpio = <&gpio2 7 GPIO_ACTIVE_LOW>;
-	host-wake-gpio = <&gpio5 21 GPIO_ACTIVE_LOW>;
-	vpcie-supply = <&reg_pcie0>;
-	status = "okay";
-};
-
-&pwm1 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pwm1>;
-	status = "okay";
-};
-
-&pwm2 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pwm2>;
-	status = "okay";
-};
-
-&pwm4 {
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pwm4>;
-	status = "okay";
-};
-
-&sai2 {
-	#sound-dai-cells = <0>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_sai2>;
-	assigned-clocks = <&clk IMX8MP_CLK_SAI2>;
-	assigned-clock-parents = <&clk IMX8MP_AUDIO_PLL1_OUT>;
-	assigned-clock-rates = <12288000>;
-	fsl,sai-mclk-direction-output;
-	status = "okay";
+	/delete-node/ panel@0;
 };
 
 &snvs_pwrkey {
@@ -838,27 +724,10 @@ &easrc {
 	status = "okay";
 };
 
-&micfil {
-	#sound-dai-cells = <0>;
-	pinctrl-names = "default";
-	pinctrl-0 = <&pinctrl_pdm>;
-	assigned-clocks = <&clk IMX8MP_CLK_PDM>;
-	assigned-clock-parents = <&clk IMX8MP_AUDIO_PLL1_OUT>;
-	assigned-clock-rates = <196608000>;
-	status = "okay";
-};
-
 &sai3 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_sai3>;
-	assigned-clocks = <&clk IMX8MP_CLK_SAI3>;
-	assigned-clock-parents = <&clk IMX8MP_AUDIO_PLL1_OUT>;
-	assigned-clock-rates = <12288000>;
-	clocks = <&audio_blk_ctrl IMX8MP_CLK_AUDIOMIX_SAI3_IPG>, <&clk IMX8MP_CLK_DUMMY>,
-		 <&audio_blk_ctrl IMX8MP_CLK_AUDIOMIX_SAI3_MCLK1>, <&clk IMX8MP_CLK_DUMMY>,
-		 <&clk IMX8MP_CLK_DUMMY>;
-	clock-names = "bus", "mclk0", "mclk1", "mclk2", "mclk3";
-	fsl,sai-mclk-direction-output;
+	/* fsl,sai-mclk-direction-output; */
 	status = "okay";
 };
 
@@ -876,12 +745,8 @@ &uart1 { /* BT */
 	pinctrl-0 = <&pinctrl_uart1>;
 	assigned-clocks = <&clk IMX8MP_CLK_UART1>;
 	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
-	uart-has-rtscts;
+	fsl,uart-has-rtscts;
 	status = "okay";
-
-	bluetooth {
-		compatible = "nxp,88w8997-bt";
-	};
 };
 
 
@@ -893,9 +758,10 @@ &uart2 {
 };
 
 &usb3_phy0 {
+	//vbus-power-supply = <&ptn5110>;
 	fsl,phy-tx-vref-tune = <0xe>;
 	fsl,phy-tx-preemp-amp-tune = <3>;
-	fsl,phy-tx-vboost-level = <5>;
+	fsl,phy-tx-vboost-level = <2>; /* set amplitude to 1.04v */
 	fsl,phy-comp-dis-tune = <7>;
 	fsl,pcs-tx-deemph-3p5db = <0x21>;
 	fsl,phy-pcs-tx-swing-full = <0x7f>;
@@ -907,21 +773,18 @@ &usb3_0 {
 };
 
 &usb_dwc3_0 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_usb0_id>;
 	dr_mode = "otg";
+	// NOTE: don't set usb-role-switch to enable extcon
+	// (patch core.c to enable extcon fn in drd.c)
+	//usb-role-switch;
+	// NOTE: dual role, not real OTG for imx8mp, no host-negocitation or session-request
 	hnp-disable;
 	srp-disable;
-	adp-disable;
-	usb-role-switch;
-	role-switch-default-mode = "none";
-	snps,dis-u1-entry-quirk;
-	snps,dis-u2-entry-quirk;
+	extcon = <&extcon_usb0>;
+	otg-rev = <0x0200>;
 	status = "okay";
-
-	port {
-		usb3_drd_sw: endpoint {
-			remote-endpoint = <&typec_dr_sw>;
-		};
-	};
 };
 
 &usb3_phy1 {
@@ -935,17 +798,24 @@ &usb3_1 {
 };
 
 &usb_dwc3_1 {
-	vbus-supply = <&reg_usb_vbus>;
 	dr_mode = "host";
 	status = "okay";
 };
 
+/* RS485 only */
 &uart3 {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_uart3>;
-	assigned-clocks = <&clk IMX8MP_CLK_UART3>;
+	status = "okay";
+};
+
+/* SP399E RS232/RS422/RS485 */
+&uart4 {
+	pinctrl-names = "default";
+	pinctrl-0 = <&pinctrl_uart4>;
+	assigned-clocks = <&clk IMX8MP_CLK_UART4>;
 	assigned-clock-parents = <&clk IMX8MP_SYS_PLL1_80M>;
-	uart-has-rtscts;
+	fsl,uart-has-rtscts;
 	status = "okay";
 };
 
@@ -981,130 +851,124 @@ &wdog1 {
 	status = "okay";
 };
 
+/*
+fsl,pins = <PIN_FUNC_ID CONFIG>,
+  - PIN_FUNC_ID is a pin (5-values) working on a specific function (MUX control)
+  - CONFIG is the pad setting (1-value) like pull-up for this pin. (PAD control)
+  see iomux-v3.h
+*/
 &iomuxc {
 	pinctrl-names = "default";
 	pinctrl-0 = <&pinctrl_hog>;
 
 	pinctrl_hog: hoggrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_HDMI_DDC_SCL__HDMIMIX_HDMI_SCL	0x400001c2
-			MX8MP_IOMUXC_HDMI_DDC_SDA__HDMIMIX_HDMI_SDA	0x400001c2
-			MX8MP_IOMUXC_HDMI_HPD__HDMIMIX_HDMI_HPD		0x40000010
-			MX8MP_IOMUXC_HDMI_CEC__HDMIMIX_HDMI_CEC		0x40000010
-			/*
-			 * M.2 pin20 & pin21 need to be set to 11 for 88W9098 to select the
-			 * default Reference Clock Frequency
-			 */
-			MX8MP_IOMUXC_SD1_DATA7__GPIO2_IO09		0x1c4
+			MX8MP_IOMUXC_HDMI_DDC_SCL__HDMIMIX_HDMI_SCL	0x400001c3
+			MX8MP_IOMUXC_HDMI_DDC_SDA__HDMIMIX_HDMI_SDA	0x400001c3
+			MX8MP_IOMUXC_HDMI_HPD__HDMIMIX_HDMI_HPD		0x40000019
+			MX8MP_IOMUXC_HDMI_CEC__HDMIMIX_HDMI_CEC		0x40000019
+
+			MX8MP_IOMUXC_SAI5_RXD2__GPIO3_IO23	0x00000106	// I2C6_INT#
+			MX8MP_IOMUXC_SD1_DATA6__GPIO2_IO08	0x00000106	// M.2 BT wakeup
+			MX8MP_IOMUXC_SD1_DATA7__GPIO2_IO09	0x00000106	// M.2 SDIO wakeup
 		>;
 	};
 
-	pinctrl_pwm1: pwm1grp {
+	pinctrl_rtc: rtcgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO01__PWM1_OUT	0x116
+			MX8MP_IOMUXC_SAI5_RXD1__GPIO3_IO22	0x80  /* RTC intr */
 		>;
 	};
 
-	pinctrl_pwm2: pwm2grp {
+	pinctrl_bl_pwm2: blpwm2grp {
 		fsl,pins = <
 			MX8MP_IOMUXC_GPIO1_IO11__PWM2_OUT	0x116
 		>;
 	};
 
-	pinctrl_pwm4: pwm4grp {
+	pinctrl_buzz_pwm4: buzzpwm4grp {
 		fsl,pins = <
 			MX8MP_IOMUXC_SAI5_RXFS__PWM4_OUT	0x116
 		>;
 	};
 
-	pinctrl_ecspi2: ecspi2grp {
+	pinctrl_tpm: tpmgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_ECSPI2_SCLK__ECSPI2_SCLK		0x82
-			MX8MP_IOMUXC_ECSPI2_MOSI__ECSPI2_MOSI		0x82
-			MX8MP_IOMUXC_ECSPI2_MISO__ECSPI2_MISO		0x82
+			MX8MP_IOMUXC_NAND_DQS__GPIO3_IO14		0xd6	// TPM IRQ
+			MX8MP_IOMUXC_GPIO1_IO06__GPIO1_IO06		0x156	// TPM reset
 		>;
 	};
 
-	pinctrl_ecspi2_cs: ecspi2cs {
+	pinctrl_usbhub_spkamp: usbhubspkampgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_ECSPI2_SS0__GPIO5_IO13		0x40000
+			MX8MP_IOMUXC_GPIO1_IO12__GPIO1_IO12		0x146	//HUB_RESET or AUDIO_AMP
 		>;
 	};
 
 	pinctrl_eqos: eqosgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC				0x2
-			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO				0x2
-			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0			0x90
-			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1			0x90
-			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2			0x90
-			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3			0x90
-			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x90
-			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL			0x90
-			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0			0x16
-			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1			0x16
-			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2			0x16
-			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3			0x16
-			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL			0x16
-			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x16
-			MX8MP_IOMUXC_SAI2_RXC__GPIO4_IO22				0x10
+			MX8MP_IOMUXC_ENET_MDC__ENET_QOS_MDC				0x3
+			MX8MP_IOMUXC_ENET_MDIO__ENET_QOS_MDIO				0x3
+			MX8MP_IOMUXC_ENET_RD0__ENET_QOS_RGMII_RD0			0x91
+			MX8MP_IOMUXC_ENET_RD1__ENET_QOS_RGMII_RD1			0x91
+			MX8MP_IOMUXC_ENET_RD2__ENET_QOS_RGMII_RD2			0x91
+			MX8MP_IOMUXC_ENET_RD3__ENET_QOS_RGMII_RD3			0x91
+			MX8MP_IOMUXC_ENET_RXC__CCM_ENET_QOS_CLOCK_GENERATE_RX_CLK	0x91
+			MX8MP_IOMUXC_ENET_RX_CTL__ENET_QOS_RGMII_RX_CTL			0x91
+			MX8MP_IOMUXC_ENET_TD0__ENET_QOS_RGMII_TD0			0x1f
+			MX8MP_IOMUXC_ENET_TD1__ENET_QOS_RGMII_TD1			0x1f
+			MX8MP_IOMUXC_ENET_TD2__ENET_QOS_RGMII_TD2			0x1f
+			MX8MP_IOMUXC_ENET_TD3__ENET_QOS_RGMII_TD3			0x1f
+			MX8MP_IOMUXC_ENET_TX_CTL__ENET_QOS_RGMII_TX_CTL			0x1f
+			MX8MP_IOMUXC_ENET_TXC__CCM_ENET_QOS_CLOCK_GENERATE_TX_CLK	0x1f
+			MX8MP_IOMUXC_SAI2_RXC__GPIO4_IO22				0x19		//ENET RESET
+			MX8MP_IOMUXC_SAI2_RXFS__GPIO4_IO21				0x00000106	//ENET INT
+			MX8MP_IOMUXC_GPIO1_IO08__ENET_QOS_1588_EVENT0_IN		0x106
+			MX8MP_IOMUXC_GPIO1_IO09__ENET_QOS_1588_EVENT0_OUT		0x106
 		>;
 	};
 
 	pinctrl_fec: fecgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x2
-			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x2
-			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x90
-			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x90
-			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x90
-			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x90
-			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x90
-			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x90
-			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x16
-			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x16
-			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x16
-			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x16
-			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x16
-			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x16
-			MX8MP_IOMUXC_SAI1_RXD0__GPIO4_IO02		0x10
+			MX8MP_IOMUXC_SAI1_RXD2__ENET1_MDC		0x3
+			MX8MP_IOMUXC_SAI1_RXD3__ENET1_MDIO		0x3
+			MX8MP_IOMUXC_SAI1_RXD4__ENET1_RGMII_RD0		0x91
+			MX8MP_IOMUXC_SAI1_RXD5__ENET1_RGMII_RD1		0x91
+			MX8MP_IOMUXC_SAI1_RXD6__ENET1_RGMII_RD2		0x91
+			MX8MP_IOMUXC_SAI1_RXD7__ENET1_RGMII_RD3		0x91
+			MX8MP_IOMUXC_SAI1_TXC__ENET1_RGMII_RXC		0x91
+			MX8MP_IOMUXC_SAI1_TXFS__ENET1_RGMII_RX_CTL	0x91
+			MX8MP_IOMUXC_SAI1_TXD0__ENET1_RGMII_TD0		0x1f
+			MX8MP_IOMUXC_SAI1_TXD1__ENET1_RGMII_TD1		0x1f
+			MX8MP_IOMUXC_SAI1_TXD2__ENET1_RGMII_TD2		0x1f
+			MX8MP_IOMUXC_SAI1_TXD3__ENET1_RGMII_TD3		0x1f
+			MX8MP_IOMUXC_SAI1_TXD4__ENET1_RGMII_TX_CTL	0x1f
+			MX8MP_IOMUXC_SAI1_TXD5__ENET1_RGMII_TXC		0x1f
+			MX8MP_IOMUXC_SAI1_RXD1__GPIO4_IO03		0x00000106	//ENET1 INT
+			MX8MP_IOMUXC_SAI1_RXD0__GPIO4_IO02		0x19		//ENET1_RESET
+			MX8MP_IOMUXC_SAI1_RXC__ENET1_1588_EVENT0_OUT	0x00000106
+			MX8MP_IOMUXC_SAI1_RXFS__ENET1_1588_EVENT0_IN	0x00000106
 		>;
 	};
 
 	pinctrl_flexcan1: flexcan1grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SPDIF_RX__CAN1_RX          0x154
-			MX8MP_IOMUXC_SPDIF_TX__CAN1_TX          0x154
-		>;
-	};
-
-	pinctrl_flexcan2: flexcan2grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SAI5_MCLK__CAN2_RX         0x154
-			MX8MP_IOMUXC_SAI5_RXD3__CAN2_TX         0x154
-		>;
-	};
-
-	pinctrl_flexcan1_reg: flexcan1reggrp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SPDIF_EXT_CLK__GPIO5_IO05  0x154   /* CAN1_STBY */
+			MX8MP_IOMUXC_SPDIF_RX__CAN1_RX		0x154
+			MX8MP_IOMUXC_SPDIF_TX__CAN1_TX		0x154
 		>;
 	};
 
-	pinctrl_flexcan2_reg: flexcan2reggrp {
+	pinctrl_ecspi2: ecspi2grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI2_MCLK__GPIO4_IO27      0x154   /* CAN2_STBY */
+			MX8MP_IOMUXC_ECSPI2_SCLK__ECSPI2_SCLK		0x82
+			MX8MP_IOMUXC_ECSPI2_MOSI__ECSPI2_MOSI		0x82
+			MX8MP_IOMUXC_ECSPI2_MISO__ECSPI2_MISO		0x82
 		>;
 	};
 
-	pinctrl_flexspi0: flexspi0grp {
+	pinctrl_ecspi2_cs: ecspi2cs {
 		fsl,pins = <
-			MX8MP_IOMUXC_NAND_ALE__FLEXSPI_A_SCLK           0x1c2
-			MX8MP_IOMUXC_NAND_CE0_B__FLEXSPI_A_SS0_B        0x82
-			MX8MP_IOMUXC_NAND_DATA00__FLEXSPI_A_DATA00      0x82
-			MX8MP_IOMUXC_NAND_DATA01__FLEXSPI_A_DATA01      0x82
-			MX8MP_IOMUXC_NAND_DATA02__FLEXSPI_A_DATA02      0x82
-			MX8MP_IOMUXC_NAND_DATA03__FLEXSPI_A_DATA03      0x82
+			MX8MP_IOMUXC_ECSPI2_SS0__GPIO5_IO13		0x40000
 		>;
 	};
 
@@ -1135,103 +999,101 @@ MX8MP_IOMUXC_I2C3_SDA__I2C3_SDA		0x400001c2
 		>;
 	};
 
-	pinctrl_i2c5: i2c5grp {
+	pinctrl_i2c6: i2c6grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SPDIF_RX__I2C5_SDA         0x400001c2
-			MX8MP_IOMUXC_SPDIF_TX__I2C5_SCL         0x400001c2
+			MX8MP_IOMUXC_UART4_RXD__I2C6_SCL	0x400001c2
+			MX8MP_IOMUXC_UART4_TXD__I2C6_SDA	0x400001c2
 		>;
 	};
 
-	pinctrl_mipi_dsi_en: mipi_dsi_en {
+	pinctrl_pmic: pmicgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO08__GPIO1_IO08	0x16
+			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x000001c0
 		>;
 	};
 
-	pinctrl_pcie0: pcie0grp {
+	pinctrl_reg_bl_en: regblengrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_I2C4_SCL__PCIE_CLKREQ_B	0x60 /* open drain, pull up */
-			MX8MP_IOMUXC_SD1_DATA5__GPIO2_IO07	0x40
-			MX8MP_IOMUXC_I2C4_SDA__GPIO5_IO21	0x1c4
+			MX8MP_IOMUXC_GPIO1_IO00__GPIO1_IO00	0x16
 		>;
 	};
 
-	pinctrl_pcie0_reg: pcie0reggrp {
+	pinctrl_reg_lvds_vdd: reglvdsvddgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SD1_DATA4__GPIO2_IO06	0x40
+			MX8MP_IOMUXC_SAI2_MCLK__GPIO4_IO27	0x16
 		>;
 	};
 
-	pinctrl_pmic: pmicgrp {
+	pinctrl_reg_lvds_bl_pwr: reglvdsblpwrgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO03__GPIO1_IO03	0x000001c0
+			MX8MP_IOMUXC_SAI5_RXC__GPIO3_IO20	0x106
+		>;
+	};
+
+	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+		fsl,pins = <
+			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x41
 		>;
 	};
 
-	pinctrl_pca6416_int: pca6416_int_grp {
+	pinctrl_sai3: sai3grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO12__GPIO1_IO12	0x146 /* Input pull-up. */
+			MX8MP_IOMUXC_SAI3_TXFS__AUDIOMIX_SAI3_TX_SYNC	0xd6
+			MX8MP_IOMUXC_SAI3_TXC__AUDIOMIX_SAI3_TX_BCLK	0xd6
+			MX8MP_IOMUXC_SAI3_RXD__AUDIOMIX_SAI3_RX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI3_TXD__AUDIOMIX_SAI3_TX_DATA00	0xd6
+			MX8MP_IOMUXC_SAI3_MCLK__AUDIOMIX_SAI3_MCLK	0xd6
 		>;
 	};
 
-	pinctrl_pwm1: pwm1grp {
+	pinctrl_i2c2_irq: i2c2irqgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO01__PWM1_OUT	0x116
+			MX8MP_IOMUXC_SAI1_TXD6__GPIO4_IO18	0x1c4
 		>;
 	};
 
-	pinctrl_pwm2: pwm2grp {
+	pinctrl_i2c3_irq: i2c3irqgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO11__PWM2_OUT	0x116
+			MX8MP_IOMUXC_SAI1_TXD7__GPIO4_IO19	0x1c4
 		>;
 	};
 
-	pinctrl_pwm4: pwm4grp {
+	pinctrl_gpio_keys: gpiokeysgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI5_RXFS__PWM4_OUT	0x116
+			MX8MP_IOMUXC_GPIO1_IO07__GPIO1_IO07	0x80 // FUNCTION_INT
 		>;
 	};
 
-	pinctrl_reg_usdhc2_vmmc: regusdhc2vmmcgrp {
+	pinctrl_hpdet: hpdetgrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SD2_RESET_B__GPIO2_IO19	0x40
+			MX8MP_IOMUXC_SAI1_MCLK__GPIO4_IO20	0x1C6
 		>;
 	};
 
-	pinctrl_pdm: pdmgrp {
+	pinctrl_usb0_pwr_en: usb0pwrengrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI5_RXC__AUDIOMIX_PDM_CLK		0xd6
-			MX8MP_IOMUXC_SAI5_RXD0__AUDIOMIX_PDM_BIT_STREAM00	0xd6
-			MX8MP_IOMUXC_SAI5_RXD1__AUDIOMIX_PDM_BIT_STREAM01	0xd6
-			MX8MP_IOMUXC_SAI5_RXD2__AUDIOMIX_PDM_BIT_STREAM02	0xd6
-			MX8MP_IOMUXC_SAI5_RXD3__AUDIOMIX_PDM_BIT_STREAM03	0xd6
+			MX8MP_IOMUXC_GPIO1_IO14__GPIO1_IO14	0x16
 		>;
 	};
 
-	pinctrl_sai2: sai2grp {
+	pinctrl_gpio1_hog: gpio1hoggrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI2_TXC__AUDIOMIX_SAI2_TX_BCLK	0xd6
-			MX8MP_IOMUXC_SAI2_TXFS__AUDIOMIX_SAI2_TX_SYNC	0xd6
-			MX8MP_IOMUXC_SAI2_TXD0__AUDIOMIX_SAI2_TX_DATA00	0xd6
-			MX8MP_IOMUXC_SAI2_RXD0__AUDIOMIX_SAI2_RX_DATA00	0xd6
+			MX8MP_IOMUXC_GPIO1_IO01__GPIO1_IO01	0x19	// GPIO_USB_MUX_SEL(Need check boot status is high or low)
 		>;
 	};
 
-	pinctrl_sai3: sai3grp {
+	pinctrl_gpio4_hog: gpio4hoggrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI3_TXFS__AUDIOMIX_SAI3_TX_SYNC	0xd6
-			MX8MP_IOMUXC_SAI3_TXC__AUDIOMIX_SAI3_TX_BCLK	0xd6
-			MX8MP_IOMUXC_SAI3_RXD__AUDIOMIX_SAI3_RX_DATA00	0xd6
-			MX8MP_IOMUXC_SAI3_TXD__AUDIOMIX_SAI3_TX_DATA00	0xd6
-			MX8MP_IOMUXC_SAI3_MCLK__AUDIOMIX_SAI3_MCLK	0xd6
-			MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28		0xd6
-			MX8MP_IOMUXC_SAI3_RXC__GPIO4_IO29		0xd6
+			MX8MP_IOMUXC_SAI2_TXFS__GPIO4_IO24	0x19	// UART_MODE0
+			MX8MP_IOMUXC_SAI2_TXC__GPIO4_IO25	0x19	// UART_MODE1
+			MX8MP_IOMUXC_SAI3_RXFS__GPIO4_IO28	0x80	// HWID_2
+			MX8MP_IOMUXC_SAI3_RXC__GPIO4_IO29	0x80	// HWID_3
 		>;
 	};
 
-	pinctrl_i2c2_synaptics_dsx_io: synaptics_dsx_iogrp {
+	pinctrl_gpio5_hog: gpio5hoggrp {
 		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO09__GPIO1_IO09		0x16
+			MX8MP_IOMUXC_SPDIF_EXT_CLK__GPIO5_IO05	0x00000106	// HWID_1
 		>;
 	};
 
@@ -1244,18 +1106,26 @@ MX8MP_IOMUXC_UART3_TXD__UART1_DCE_RTS	0x140
 		>;
 	};
 
-	pinctrl_typec: typec1grp {
+	pinctrl_usb0_id: usb0-id-grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI1_TXD7__GPIO4_IO19	0x1c4
+			// MX8MP_IOMUXC_GPIO1_IO10__USB1_ID		0x19 // DNU - do not use
+			MX8MP_IOMUXC_GPIO1_IO10__GPIO1_IO10		0x19
 		>;
 	};
 
-	pinctrl_typec_mux: typec1muxgrp {
+	pinctrl_usb0_oc: usb0-oc-grp {
 		fsl,pins = <
-			MX8MP_IOMUXC_SAI1_MCLK__GPIO4_IO20	0x16
+			// MX8MP_IOMUXC_GPIO1_IO15__USB2_OC		0x19
+			MX8MP_IOMUXC_GPIO1_IO15__GPIO1_IO15		0x19
 		>;
 	};
 
+//	pinctrl_usb1_oc: usb1ocgrp {
+//		fsl,pins = <
+//			MX8MP_IOMUXC_GPIO1_IO13__USB1_OC		0x19
+//		>;
+//	};
+
 	pinctrl_uart2: uart2grp {
 		fsl,pins = <
 			MX8MP_IOMUXC_UART2_RXD__UART2_DCE_RX	0x140
@@ -1263,12 +1133,6 @@ MX8MP_IOMUXC_UART2_TXD__UART2_DCE_TX	0x140
 		>;
 	};
 
-	pinctrl_usb1_vbus: usb1grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO14__GPIO1_IO14		0x10
-		>;
-	};
-
 	pinctrl_uart3: uart3grp {
 		fsl,pins = <
 			MX8MP_IOMUXC_ECSPI1_SCLK__UART3_DCE_RX		0x140
@@ -1278,6 +1142,15 @@ MX8MP_IOMUXC_ECSPI1_MISO__UART3_DCE_CTS		0x140
 		>;
 	};
 
+	pinctrl_uart4: uart4grp {
+		fsl,pins = <
+			MX8MP_IOMUXC_NAND_DATA00__UART4_DCE_RX		0x140
+			MX8MP_IOMUXC_NAND_DATA01__UART4_DCE_TX		0x140
+			MX8MP_IOMUXC_NAND_DATA02__UART4_DCE_CTS		0x140
+			MX8MP_IOMUXC_NAND_DATA03__UART4_DCE_RTS		0x140
+		>;
+	};
+
 	pinctrl_usdhc2: usdhc2grp {
 		fsl,pins = <
 			MX8MP_IOMUXC_SD2_CLK__USDHC2_CLK	0x190
@@ -1286,7 +1159,7 @@ MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d0
 			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d0
 			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d0
 			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d0
-			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT	0xc1
 		>;
 	};
 
@@ -1298,7 +1171,7 @@ MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d4
 			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d4
 			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d4
 			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d4
-			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
 		>;
 	};
 
@@ -1310,7 +1183,7 @@ MX8MP_IOMUXC_SD2_DATA0__USDHC2_DATA0	0x1d6
 			MX8MP_IOMUXC_SD2_DATA1__USDHC2_DATA1	0x1d6
 			MX8MP_IOMUXC_SD2_DATA2__USDHC2_DATA2	0x1d6
 			MX8MP_IOMUXC_SD2_DATA3__USDHC2_DATA3	0x1d6
-			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc0
+			MX8MP_IOMUXC_GPIO1_IO04__USDHC2_VSELECT 0xc1
 		>;
 	};
 
@@ -1373,24 +1246,6 @@ pinctrl_wdog: wdoggrp {
 			MX8MP_IOMUXC_GPIO1_IO02__WDOG1_WDOG_B	0x166
 		>;
 	};
-
-	pinctrl_csi0_pwn: csi0_pwn_grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_SD1_STROBE__GPIO2_IO11	0x10
-		>;
-	};
-
-	pinctrl_csi0_rst: csi0_rst_grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO06__GPIO1_IO06		0x10
-		>;
-	};
-
-	pinctrl_csi_mclk: csi_mclk_grp {
-		fsl,pins = <
-			MX8MP_IOMUXC_GPIO1_IO15__CCM_CLKO2	0x50
-		>;
-	};
 };
 
 &vpu_g1 {
@@ -1424,58 +1279,3 @@ &ml_vipsi {
 &mix_gpu_ml {
 	status = "okay";
 };
-
-&mipi_csi_0 {
-	status = "okay";
-
-	port {
-		mipi_csi0_ep: endpoint {
-			remote-endpoint = <&ov5640_mipi_0_ep>;
-			data-lanes = <2>;
-			csis-hs-settle = <13>;
-			csis-clk-settle = <2>;
-			csis-wclk;
-		};
-	};
-};
-
-&mipi_csi_1 {
-	#address-cells = <1>;
-	#size-cells = <0>;
-	status = "disabled";
-
-	port@1 {
-		reg = <1>;
-		mipi_csi1_ep: endpoint {
-			remote-endpoint = <&ov5640_mipi_1_ep>;
-			data-lanes = <2>;
-			csis-hs-settle = <13>;
-			csis-clk-settle = <2>;
-			csis-wclk;
-		};
-	};
-};
-
-&cameradev {
-	status = "okay";
-};
-
-&isi_0 {
-	status = "okay";
-
-	cap_device {
-		status = "okay";
-	};
-
-	m2m_device {
-		status = "okay";
-	};
-};
-
-&isi_1 {
-	status = "disabled";
-
-	cap_device {
-		status = "okay";
-	};
-};
diff --git a/arch/arm64/boot/dts/freescale/imx8mp.dtsi b/arch/arm64/boot/dts/freescale/imx8mp.dtsi
index 108ef142b724..5b7b56e92c21 100644
--- a/arch/arm64/boot/dts/freescale/imx8mp.dtsi
+++ b/arch/arm64/boot/dts/freescale/imx8mp.dtsi
@@ -12,7 +12,7 @@
 #include <dt-bindings/interrupt-controller/arm-gic.h>
 #include <dt-bindings/thermal/thermal.h>
 
-#include "imx8mp-pinfunc.h"
+#include "../freescale/imx8mp-pinfunc.h"
 
 / {
 	interrupt-parent = <&gic>;
@@ -182,6 +182,15 @@ opp-1600000000 {
 			opp-suspend;
 		};
 
+		/* Only for Special Industrial part with 1.8G at OD */
+		opp-sc-1800000000 {
+			opp-hz = /bits/ 64 <1800000000>;
+			opp-microvolt = <950000>;
+			opp-supported-hw = <0x20>, <0x4>;
+			clock-latency-ns = <150000>;
+			opp-suspend;
+		};
+
 		opp-1800000000 {
 			opp-hz = /bits/ 64 <1800000000>;
 			opp-microvolt = <1000000>;
@@ -218,14 +227,14 @@ ocram: ocram@900000 {
 		linux,cma {
 			compatible = "shared-dma-pool";
 			reusable;
-			size = <0 0x3c000000>;
-			alloc-ranges = <0 0x40000000 0 0xC0000000>;
+			size = <0 0x20000000>;
+			alloc-ranges = <0 0x40000000 0 0xA0000000>;
 			linux,cma-default;
 		};
 
 		gpu_reserved: gpu_reserved@100000000 {
 			no-map;
-			reg = <0x1 0x00000000 0 0x10000000>;
+			reg = <0 0xB0000000 0 0x02000000>;
 		};
 
 		dsp_reserved: dsp@92400000 {
@@ -378,13 +387,13 @@ cpu-thermal {
 			thermal-sensors = <&tmu 0>;
 			trips {
 				cpu_alert0: trip0 {
-					temperature = <85000>;
+					temperature = <100000>;
 					hysteresis = <2000>;
 					type = "passive";
 				};
 
 				cpu_crit0: trip1 {
-					temperature = <95000>;
+					temperature = <105000>;
 					hysteresis = <2000>;
 					type = "critical";
 				};
@@ -409,13 +418,13 @@ soc-thermal {
 			thermal-sensors = <&tmu 1>;
 			trips {
 				soc_alert0: trip0 {
-					temperature = <85000>;
+					temperature = <100000>;
 					hysteresis = <2000>;
 					type = "passive";
 				};
 
 				soc_crit0: trip1 {
-					temperature = <95000>;
+					temperature = <105000>;
 					hysteresis = <2000>;
 					type = "critical";
 				};
@@ -1911,6 +1920,7 @@ xcvr: xcvr@30cc0000 {
 					dma-names = "rx", "tx";
 					resets = <&audio_blk_ctrl 0>;
 					power-domains = <&audiomix_pd>;
+					hdmi-phandle = <&hdmi>;
 					status = "disabled";
 				};
 			};
@@ -1924,7 +1934,6 @@ sdma3: dma-controller@30e00000 {
 				clock-names = "ipg", "ahb";
 				#dma-cells = <3>;
 				fsl,sdma-ram-script-name = "imx/sdma/sdma-imx7d.bin";
-				fsl,ratio-1-1;
 				power-domains = <&audiomix_pd>;
 				status = "disabled";
 			};
@@ -1938,7 +1947,6 @@ sdma2: dma-controller@30e10000 {
 				clock-names = "ipg", "ahb";
 				#dma-cells = <3>;
 				fsl,sdma-ram-script-name = "imx/sdma/sdma-imx7d.bin";
-				fsl,ratio-1-1;
 				power-domains = <&audiomix_pd>;
 				status = "disabled";
 			};
@@ -2128,8 +2136,11 @@ pcie: pcie@33800000 {
 
 		pcie_ep: pcie-ep@33800000 {
 			compatible = "fsl,imx8mp-pcie-ep";
-			reg = <0x33800000 0x000400000>, <0x18000000 0x08000000>;
-			reg-names = "dbi", "addr_space";
+			reg = <0x33800000 0x100000>,
+			      <0x33900000 0x100000>,
+			      <0x33b00000 0x100000>,
+			      <0x18000000 0x8000000>;
+			reg-names = "dbi", "dbi2", "atu", "addr_space";
 			clocks = <&clk IMX8MP_CLK_HSIO_ROOT>,
 				 <&clk IMX8MP_CLK_HSIO_AXI>,
 				 <&clk IMX8MP_CLK_PCIE_ROOT>;
@@ -2483,3 +2494,4 @@ i2c_rpbus_3: i2c-rpbus-3 {
 		status = "disabled";
 	};
 };
+
diff --git a/drivers/char/tpm/tpm_tis_i2c.c b/drivers/char/tpm/tpm_tis_i2c.c
index a897402cc36a..ba803088432f 100644
--- a/drivers/char/tpm/tpm_tis_i2c.c
+++ b/drivers/char/tpm/tpm_tis_i2c.c
@@ -291,7 +291,7 @@ static int tpm_tis_i2c_verify_crc(struct tpm_tis_data *data, size_t len,
  *
  * See TCG PC Client PTP Specification v1.04, 8.1.10 GUARD_TIME
  */
-static int tpm_tis_i2c_init_guard_time(struct tpm_tis_i2c_phy *phy)
+static int tpm_tis_i2c_init_guard_time(struct tpm_tis_i2c_phy *phy, bool default_guard_time)
 {
 	u32 i2c_caps;
 	int ret;
@@ -301,6 +301,8 @@ static int tpm_tis_i2c_init_guard_time(struct tpm_tis_i2c_phy *phy)
 	phy->guard_time_min = GUARD_TIME_DEFAULT_MIN;
 	phy->guard_time_max = GUARD_TIME_DEFAULT_MAX;
 
+	if (default_guard_time)	return 0;
+
 	ret = tpm_tis_i2c_read_bytes(&phy->priv, TPM_I2C_INTERFACE_CAPABILITY,
 				     sizeof(i2c_caps), (u8 *)&i2c_caps,
 				     TPM_TIS_PHYS_32);
@@ -329,9 +331,11 @@ static const struct tpm_tis_phy_ops tpm_i2c_phy_ops = {
 
 static int tpm_tis_i2c_probe(struct i2c_client *dev)
 {
+	struct device *bdev = &dev->dev;
 	struct tpm_tis_i2c_phy *phy;
 	const u8 crc_enable = 1;
 	const u8 locality = 0;
+	bool default_guard_time = false;
 	int ret;
 
 	phy = devm_kzalloc(&dev->dev, sizeof(struct tpm_tis_i2c_phy),
@@ -346,8 +350,11 @@ static int tpm_tis_i2c_probe(struct i2c_client *dev)
 	set_bit(TPM_TIS_DEFAULT_CANCELLATION, &phy->priv.flags);
 	phy->i2c_client = dev;
 
+	default_guard_time = of_property_read_bool(bdev->of_node, "default-guard-time");
+	if (default_guard_time)
+		pr_info("tpm: use default guard time\n");
 	/* must precede all communication with the tpm */
-	ret = tpm_tis_i2c_init_guard_time(phy);
+	ret = tpm_tis_i2c_init_guard_time(phy, default_guard_time);
 	if (ret)
 		return ret;
 
@@ -383,6 +390,7 @@ MODULE_DEVICE_TABLE(i2c, tpm_tis_i2c_id);
 #ifdef CONFIG_OF
 static const struct of_device_id of_tis_i2c_match[] = {
 	{ .compatible = "infineon,slb9673", },
+	{ .compatible = "st,st33htpm-i2c", },
 	{}
 };
 MODULE_DEVICE_TABLE(of, of_tis_i2c_match);
diff --git a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
index 7838947a1bf3..067d4088cd2a 100644
--- a/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
+++ b/drivers/gpu/drm/panel/panel-ilitek-ili9881c.c
@@ -41,7 +41,7 @@ struct ili9881c_desc {
 	const struct ili9881c_instr *init;
 	const size_t init_length;
 	const struct drm_display_mode *mode;
-	const unsigned long mode_flags;
+	unsigned int mode_flags;
 };
 
 struct ili9881c {
@@ -830,6 +830,407 @@ static const struct ili9881c_instr w552946ab_init[] = {
 	ILI9881C_SWITCH_PAGE_INSTR(0),
 };
 
+static const struct ili9881c_instr am_8001280gtzqw_init[] = {
+	ILI9881C_SWITCH_PAGE_INSTR(3),
+	ILI9881C_COMMAND_INSTR(0x01, 0x00),
+	ILI9881C_COMMAND_INSTR(0x02, 0x00),
+	ILI9881C_COMMAND_INSTR(0x03, 0x73),
+	ILI9881C_COMMAND_INSTR(0x04, 0xD3),
+	ILI9881C_COMMAND_INSTR(0x05, 0x00),
+	ILI9881C_COMMAND_INSTR(0x06, 0x0A),
+	ILI9881C_COMMAND_INSTR(0x07, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x08, 0x00),
+	ILI9881C_COMMAND_INSTR(0x09, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0A, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0B, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0C, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0D, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0E, 0x01),
+	ILI9881C_COMMAND_INSTR(0x0F, 0x01),
+	ILI9881C_COMMAND_INSTR(0x10, 0x01),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+	ILI9881C_COMMAND_INSTR(0x12, 0x00),
+	ILI9881C_COMMAND_INSTR(0x13, 0x00),
+	ILI9881C_COMMAND_INSTR(0x14, 0x00),
+	ILI9881C_COMMAND_INSTR(0x15, 0x00),
+	ILI9881C_COMMAND_INSTR(0x16, 0x00),
+	ILI9881C_COMMAND_INSTR(0x17, 0x00),
+	ILI9881C_COMMAND_INSTR(0x18, 0x00),
+	ILI9881C_COMMAND_INSTR(0x19, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1E, 0x40),
+	ILI9881C_COMMAND_INSTR(0x1F, 0x80),
+	ILI9881C_COMMAND_INSTR(0x20, 0x06),
+	ILI9881C_COMMAND_INSTR(0x21, 0x01),
+	ILI9881C_COMMAND_INSTR(0x22, 0x00),
+	ILI9881C_COMMAND_INSTR(0x23, 0x00),
+	ILI9881C_COMMAND_INSTR(0x24, 0x00),
+	ILI9881C_COMMAND_INSTR(0x25, 0x00),
+	ILI9881C_COMMAND_INSTR(0x26, 0x00),
+	ILI9881C_COMMAND_INSTR(0x27, 0x00),
+	ILI9881C_COMMAND_INSTR(0x28, 0x33),
+	ILI9881C_COMMAND_INSTR(0x29, 0x03),
+	ILI9881C_COMMAND_INSTR(0x2A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x30, 0x00),
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x32, 0x00),
+	ILI9881C_COMMAND_INSTR(0x33, 0x00),
+	ILI9881C_COMMAND_INSTR(0x34, 0x03),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x36, 0x03),
+	ILI9881C_COMMAND_INSTR(0x37, 0x00),
+	ILI9881C_COMMAND_INSTR(0x38, 0x00),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x40),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x40),
+	ILI9881C_COMMAND_INSTR(0x3C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x40, 0x00),
+	ILI9881C_COMMAND_INSTR(0x41, 0x00),
+	ILI9881C_COMMAND_INSTR(0x42, 0x00),
+	ILI9881C_COMMAND_INSTR(0x43, 0x00),
+	ILI9881C_COMMAND_INSTR(0x44, 0x00),
+	ILI9881C_COMMAND_INSTR(0x50, 0x01),
+	ILI9881C_COMMAND_INSTR(0x51, 0x23),
+	ILI9881C_COMMAND_INSTR(0x52, 0x45),
+	ILI9881C_COMMAND_INSTR(0x53, 0x67),
+	ILI9881C_COMMAND_INSTR(0x54, 0x89),
+	ILI9881C_COMMAND_INSTR(0x55, 0xAB),
+	ILI9881C_COMMAND_INSTR(0x56, 0x01),
+	ILI9881C_COMMAND_INSTR(0x57, 0x23),
+	ILI9881C_COMMAND_INSTR(0x58, 0x45),
+	ILI9881C_COMMAND_INSTR(0x59, 0x67),
+	ILI9881C_COMMAND_INSTR(0x5A, 0x89),
+	ILI9881C_COMMAND_INSTR(0x5B, 0xAB),
+	ILI9881C_COMMAND_INSTR(0x5C, 0xCD),
+	ILI9881C_COMMAND_INSTR(0x5D, 0xEF),
+	ILI9881C_COMMAND_INSTR(0x5E, 0x11),
+	ILI9881C_COMMAND_INSTR(0x5F, 0x02),
+	ILI9881C_COMMAND_INSTR(0x60, 0x00),
+	ILI9881C_COMMAND_INSTR(0x61, 0x01),
+	ILI9881C_COMMAND_INSTR(0x62, 0x0D),
+	ILI9881C_COMMAND_INSTR(0x63, 0x0C),
+	ILI9881C_COMMAND_INSTR(0x64, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x65, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x66, 0x06),
+	ILI9881C_COMMAND_INSTR(0x67, 0x07),
+	ILI9881C_COMMAND_INSTR(0x68, 0x02),
+	ILI9881C_COMMAND_INSTR(0x69, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6A, 0x08),
+	ILI9881C_COMMAND_INSTR(0x6B, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6D, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x02),
+	ILI9881C_COMMAND_INSTR(0x6F, 0x02),
+	ILI9881C_COMMAND_INSTR(0x70, 0x02),
+	ILI9881C_COMMAND_INSTR(0x71, 0x02),
+	ILI9881C_COMMAND_INSTR(0x72, 0x02),
+	ILI9881C_COMMAND_INSTR(0x73, 0x02),
+	ILI9881C_COMMAND_INSTR(0x74, 0x02),
+	ILI9881C_COMMAND_INSTR(0x75, 0x02),
+	ILI9881C_COMMAND_INSTR(0x76, 0x00),
+	ILI9881C_COMMAND_INSTR(0x77, 0x01),
+	ILI9881C_COMMAND_INSTR(0x78, 0x0D),
+	ILI9881C_COMMAND_INSTR(0x79, 0x0C),
+	ILI9881C_COMMAND_INSTR(0x7A, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x7B, 0x0E),
+	ILI9881C_COMMAND_INSTR(0x7C, 0x06),
+	ILI9881C_COMMAND_INSTR(0x7D, 0x07),
+	ILI9881C_COMMAND_INSTR(0x7E, 0x02),
+	ILI9881C_COMMAND_INSTR(0x7F, 0x02),
+	ILI9881C_COMMAND_INSTR(0x80, 0x08),
+	ILI9881C_COMMAND_INSTR(0x81, 0x02),
+	ILI9881C_COMMAND_INSTR(0x82, 0x02),
+	ILI9881C_COMMAND_INSTR(0x83, 0x02),
+	ILI9881C_COMMAND_INSTR(0x84, 0x02),
+	ILI9881C_COMMAND_INSTR(0x85, 0x02),
+	ILI9881C_COMMAND_INSTR(0x86, 0x02),
+	ILI9881C_COMMAND_INSTR(0x87, 0x02),
+	ILI9881C_COMMAND_INSTR(0x88, 0x02),
+	ILI9881C_COMMAND_INSTR(0x89, 0x02),
+	ILI9881C_COMMAND_INSTR(0x8A, 0x02),
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15),
+	ILI9881C_COMMAND_INSTR(0x6E, 0x30),
+	ILI9881C_COMMAND_INSTR(0x6F, 0x33),
+	ILI9881C_COMMAND_INSTR(0x8D, 0x15),
+	ILI9881C_COMMAND_INSTR(0x3A, 0xA4),
+	ILI9881C_COMMAND_INSTR(0x87, 0xBA),
+	ILI9881C_COMMAND_INSTR(0x26, 0x76),
+	ILI9881C_COMMAND_INSTR(0xB2, 0xD1),
+	ILI9881C_SWITCH_PAGE_INSTR(1),
+	ILI9881C_COMMAND_INSTR(0x22, 0x0A),
+	ILI9881C_COMMAND_INSTR(0x31, 0x0B),
+	ILI9881C_COMMAND_INSTR(0x50, 0xA5),
+	ILI9881C_COMMAND_INSTR(0x51, 0xA0),
+	ILI9881C_COMMAND_INSTR(0x53, 0x70),
+	ILI9881C_COMMAND_INSTR(0x55, 0x7A),
+	ILI9881C_COMMAND_INSTR(0x60, 0x14),
+	ILI9881C_COMMAND_INSTR(0xA0, 0x00),
+	ILI9881C_COMMAND_INSTR(0xA1, 0x53),
+	ILI9881C_COMMAND_INSTR(0xA2, 0x50),
+	ILI9881C_COMMAND_INSTR(0xA3, 0x20),
+	ILI9881C_COMMAND_INSTR(0xA4, 0x27),
+	ILI9881C_COMMAND_INSTR(0xA5, 0x33),
+	ILI9881C_COMMAND_INSTR(0xA6, 0x25),
+	ILI9881C_COMMAND_INSTR(0xA7, 0x25),
+	ILI9881C_COMMAND_INSTR(0xA8, 0xD4),
+	ILI9881C_COMMAND_INSTR(0xA9, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xAA, 0x2B),
+	ILI9881C_COMMAND_INSTR(0xAB, 0xB5),
+	ILI9881C_COMMAND_INSTR(0xAC, 0x19),
+	ILI9881C_COMMAND_INSTR(0xAD, 0x18),
+	ILI9881C_COMMAND_INSTR(0xAE, 0x53),
+	ILI9881C_COMMAND_INSTR(0xAF, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xB0, 0x25),
+	ILI9881C_COMMAND_INSTR(0xB1, 0x62),
+	ILI9881C_COMMAND_INSTR(0xB2, 0x6A),
+	ILI9881C_COMMAND_INSTR(0xB3, 0x31),
+	ILI9881C_COMMAND_INSTR(0xC0, 0x00),
+	ILI9881C_COMMAND_INSTR(0xC1, 0x53),
+	ILI9881C_COMMAND_INSTR(0xC2, 0x50),
+	ILI9881C_COMMAND_INSTR(0xC3, 0x20),
+	ILI9881C_COMMAND_INSTR(0xC4, 0x27),
+	ILI9881C_COMMAND_INSTR(0xC5, 0x33),
+	ILI9881C_COMMAND_INSTR(0xC6, 0x25),
+	ILI9881C_COMMAND_INSTR(0xC7, 0x25),
+	ILI9881C_COMMAND_INSTR(0xC8, 0xD4),
+	ILI9881C_COMMAND_INSTR(0xC9, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xCA, 0x2B),
+	ILI9881C_COMMAND_INSTR(0xCB, 0xB5),
+	ILI9881C_COMMAND_INSTR(0xCC, 0x19),
+	ILI9881C_COMMAND_INSTR(0xCD, 0x18),
+	ILI9881C_COMMAND_INSTR(0xCE, 0x53),
+	ILI9881C_COMMAND_INSTR(0xCF, 0x1A),
+	ILI9881C_COMMAND_INSTR(0xD0, 0x25),
+	ILI9881C_COMMAND_INSTR(0xD1, 0x62),
+	ILI9881C_COMMAND_INSTR(0xD2, 0x6A),
+	ILI9881C_COMMAND_INSTR(0xD3, 0x31),
+	ILI9881C_SWITCH_PAGE_INSTR(0),
+	ILI9881C_COMMAND_INSTR(0x51, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x53, 0x2C),
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+};
+
+
+static const struct ili9881c_instr hsd_p0711t_init[] = {
+	// CMD_Page 3
+	ILI9881C_SWITCH_PAGE_INSTR(3),
+	//=========GIP_1===========//
+	ILI9881C_COMMAND_INSTR(0x01, 0x00),
+	ILI9881C_COMMAND_INSTR(0x02, 0x00),
+	ILI9881C_COMMAND_INSTR(0x03, 0x54), //STVA Width 5H
+	ILI9881C_COMMAND_INSTR(0x04, 0x14), //STVB Width 5H
+	ILI9881C_COMMAND_INSTR(0x05, 0xD4), //STVC Width 5H
+	ILI9881C_COMMAND_INSTR(0x06, 0x08), //STVA Rise start
+	ILI9881C_COMMAND_INSTR(0x07, 0x01), //STVB Rise start
+	ILI9881C_COMMAND_INSTR(0x08, 0x0E), //STVC Rise start
+	ILI9881C_COMMAND_INSTR(0x09, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x0F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x10, 0x00),
+	ILI9881C_COMMAND_INSTR(0x11, 0x00),
+	ILI9881C_COMMAND_INSTR(0x12, 0x00),
+	ILI9881C_COMMAND_INSTR(0x13, 0x00),
+	ILI9881C_COMMAND_INSTR(0x14, 0x00),
+	ILI9881C_COMMAND_INSTR(0x15, 0x00),
+	ILI9881C_COMMAND_INSTR(0x16, 0x00),
+	ILI9881C_COMMAND_INSTR(0x17, 0x00),
+	ILI9881C_COMMAND_INSTR(0x18, 0x00),
+	ILI9881C_COMMAND_INSTR(0x19, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x1E, 0x44),
+	ILI9881C_COMMAND_INSTR(0x1F, 0x80),
+	ILI9881C_COMMAND_INSTR(0x20, 0x03), //CLKA Rise STA
+	ILI9881C_COMMAND_INSTR(0x21, 0x04), //CLKA FALL END
+	ILI9881C_COMMAND_INSTR(0x22, 0x00),
+	ILI9881C_COMMAND_INSTR(0x23, 0x00),
+	ILI9881C_COMMAND_INSTR(0x24, 0x00),
+	ILI9881C_COMMAND_INSTR(0x25, 0x00),
+	ILI9881C_COMMAND_INSTR(0x26, 0x00),
+	ILI9881C_COMMAND_INSTR(0x27, 0x00),
+	ILI9881C_COMMAND_INSTR(0x28, 0x77), //CLK_x_NumB[2:0]  Phase_CLK[2:0]
+	ILI9881C_COMMAND_INSTR(0x29, 0x04), //Overlap_CLK[3:0] 5H
+	ILI9881C_COMMAND_INSTR(0x2A, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2B, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x2F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x30, 0x00),
+	ILI9881C_COMMAND_INSTR(0x31, 0x00),
+	ILI9881C_COMMAND_INSTR(0x32, 0x00),
+	ILI9881C_COMMAND_INSTR(0x33, 0x00),
+	ILI9881C_COMMAND_INSTR(0x34, 0x04), //GPW1/2 non Overlap time 2.62us
+	ILI9881C_COMMAND_INSTR(0x35, 0x00),
+	ILI9881C_COMMAND_INSTR(0x36, 0x00),
+	ILI9881C_COMMAND_INSTR(0x37, 0x00),
+	ILI9881C_COMMAND_INSTR(0x38, 0x3C), //FOR GPW1/2 Cycle 2 s
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3A, 0x40),
+	ILI9881C_COMMAND_INSTR(0x3B, 0x40),
+	ILI9881C_COMMAND_INSTR(0x3C, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3D, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3E, 0x00),
+	ILI9881C_COMMAND_INSTR(0x3F, 0x00),
+	ILI9881C_COMMAND_INSTR(0x40, 0x00),
+	ILI9881C_COMMAND_INSTR(0x41, 0x00),
+	ILI9881C_COMMAND_INSTR(0x42, 0x00),
+	ILI9881C_COMMAND_INSTR(0x43, 0x00),
+	ILI9881C_COMMAND_INSTR(0x44, 0x00),
+	//=========GIP_2===========//
+	ILI9881C_COMMAND_INSTR(0x50, 0x01),
+	ILI9881C_COMMAND_INSTR(0x51, 0x23),
+	ILI9881C_COMMAND_INSTR(0x52, 0x45),
+	ILI9881C_COMMAND_INSTR(0x53, 0x67),
+	ILI9881C_COMMAND_INSTR(0x54, 0x89),
+	ILI9881C_COMMAND_INSTR(0x55, 0xAB),
+	ILI9881C_COMMAND_INSTR(0x56, 0x01),
+	ILI9881C_COMMAND_INSTR(0x57, 0x23),
+	ILI9881C_COMMAND_INSTR(0x58, 0x45),
+	ILI9881C_COMMAND_INSTR(0x59, 0x67),
+	ILI9881C_COMMAND_INSTR(0x5A, 0x89),
+	ILI9881C_COMMAND_INSTR(0x5B, 0xAB),
+	ILI9881C_COMMAND_INSTR(0x5C, 0xCD),
+	ILI9881C_COMMAND_INSTR(0x5D, 0xEF),
+	//=========GIP_3===========//
+	ILI9881C_COMMAND_INSTR(0x5E, 0x11),
+	ILI9881C_COMMAND_INSTR(0x5F, 0x01), //FW_GOUT_L1   FW
+	ILI9881C_COMMAND_INSTR(0x60, 0x00), //FW_GOUT_L2   BW
+	ILI9881C_COMMAND_INSTR(0x61, 0x08), //FW_GOUT_L3   STV2_R
+	ILI9881C_COMMAND_INSTR(0x62, 0x0A), //FW_GOUT_L4   STV3_R
+	ILI9881C_COMMAND_INSTR(0x63, 0x15), //FW_GOUT_L5   GPW1_R
+	ILI9881C_COMMAND_INSTR(0x64, 0x14), //FW_GOUT_L6   GPW2_R
+	ILI9881C_COMMAND_INSTR(0x65, 0x0C), //FW_GOUT_L7   CLK1_R
+	ILI9881C_COMMAND_INSTR(0x66, 0x0D), //FW_GOUT_L8   CLK2_R
+	ILI9881C_COMMAND_INSTR(0x67, 0x0E), //FW_GOUT_L9   CLK3_R
+	ILI9881C_COMMAND_INSTR(0x68, 0x0F), //FW_GOUT_L10  CLK4_R
+	ILI9881C_COMMAND_INSTR(0x69, 0x10), //FW_GOUT_L11  CLK5_R
+	ILI9881C_COMMAND_INSTR(0x6A, 0x11), //FW_GOUT_L12  CLK6_R
+	ILI9881C_COMMAND_INSTR(0x6B, 0x12), //FW_GOUT_L13  CLK7_R
+	ILI9881C_COMMAND_INSTR(0x6C, 0x13), //FW_GOUT_L14  CLK8_R
+	ILI9881C_COMMAND_INSTR(0x6D, 0x06), //FW_GOUT_L15  STV1_R
+	ILI9881C_COMMAND_INSTR(0x6E, 0x02), //FW_GOUT_L16
+	ILI9881C_COMMAND_INSTR(0x6F, 0x02), //FW_GOUT_L17  VGL
+	ILI9881C_COMMAND_INSTR(0x70, 0x02), //FW_GOUT_L18  VGL
+	ILI9881C_COMMAND_INSTR(0x71, 0x02), //FW_GOUT_L19  VGL
+	ILI9881C_COMMAND_INSTR(0x72, 0x02), //FW_GOUT_L20
+	ILI9881C_COMMAND_INSTR(0x73, 0x02), //FW_GOUT_L21
+	ILI9881C_COMMAND_INSTR(0x74, 0x02), //FW_GOUT_L22
+	ILI9881C_COMMAND_INSTR(0x75, 0x01), //BW_GOUT_L1   FW
+	ILI9881C_COMMAND_INSTR(0x76, 0x00), //BW_GOUT_L2   BW
+	ILI9881C_COMMAND_INSTR(0x77, 0x06), //BW_GOUT_L3   STV2_R
+	ILI9881C_COMMAND_INSTR(0x78, 0x0A), //BW_GOUT_L4   STV3_R
+	ILI9881C_COMMAND_INSTR(0x79, 0x15), //BW_GOUT_L5   GPW1_R
+	ILI9881C_COMMAND_INSTR(0x7A, 0x14), //BW_GOUT_L6   GPW2_R
+	ILI9881C_COMMAND_INSTR(0x7B, 0x0C), //BW_GOUT_L7   CLK1_R
+	ILI9881C_COMMAND_INSTR(0x7C, 0x0D), //BW_GOUT_L8   CLK2_R
+	ILI9881C_COMMAND_INSTR(0x7D, 0x0E), //BW_GOUT_L9   CLK3_R
+	ILI9881C_COMMAND_INSTR(0x7E, 0x0F), //BW_GOUT_L10  CLK4_R
+	ILI9881C_COMMAND_INSTR(0x7F, 0x10), //BW_GOUT_L11  CLK5_R
+	ILI9881C_COMMAND_INSTR(0x80, 0x11), //BW_GOUT_L12  CLK6_R
+	ILI9881C_COMMAND_INSTR(0x81, 0x12), //BW_GOUT_L13  CLK7_R
+	ILI9881C_COMMAND_INSTR(0x82, 0x13), //BW_GOUT_L14  CLK8_R
+	ILI9881C_COMMAND_INSTR(0x83, 0x08), //BW_GOUT_L15  STV1_R
+	ILI9881C_COMMAND_INSTR(0x84, 0x02), //BW_GOUT_L16
+	ILI9881C_COMMAND_INSTR(0x85, 0x02), //BW_GOUT_L17  VGL
+	ILI9881C_COMMAND_INSTR(0x86, 0x02), //BW_GOUT_L18  VGL
+	ILI9881C_COMMAND_INSTR(0x87, 0x02), //BW_GOUT_L19  VGL
+	ILI9881C_COMMAND_INSTR(0x88, 0x02), //BW_GOUT_L20
+	ILI9881C_COMMAND_INSTR(0x89, 0x02), //BW_GOUT_L21
+	ILI9881C_COMMAND_INSTR(0x8A, 0x02), //BW_GOUT_L22
+	// CMD_Page 4
+	ILI9881C_SWITCH_PAGE_INSTR(4),
+	ILI9881C_COMMAND_INSTR(0x6C, 0x15), //SEt VCORE voltAgE =1.5V
+	ILI9881C_COMMAND_INSTR(0x6E, 0x3B), //di_pwr_reg=0 For power mode 2A //VGH Clamp 18.06V
+	ILI9881C_COMMAND_INSTR(0x6F, 0x33), //Reg vCl + pumping ratio VGH=3x VGL=-2x
+	ILI9881C_COMMAND_INSTR(0x3A, 0x24), //POWER SAVING
+	ILI9881C_COMMAND_INSTR(0x8D, 0x14), //VGL -10.05V
+	ILI9881C_COMMAND_INSTR(0x87, 0xBA), //ESD
+	ILI9881C_COMMAND_INSTR(0x26, 0x76),
+	ILI9881C_COMMAND_INSTR(0xB2, 0xD1),
+	ILI9881C_COMMAND_INSTR(0xB5, 0x27), //GMA BIAS
+	ILI9881C_COMMAND_INSTR(0x31, 0x75), //SRC BIAS
+	ILI9881C_COMMAND_INSTR(0x30, 0x03), //SRC OUTPUT BIAS
+	ILI9881C_COMMAND_INSTR(0x3B, 0x98), //PUMP SHIFT CLK
+	ILI9881C_COMMAND_INSTR(0x35, 0x1F), //HZ_opt 0426
+	ILI9881C_COMMAND_INSTR(0x33, 0x14), //Blanking Frame set to GND
+	ILI9881C_COMMAND_INSTR(0x7A, 0x0F),
+	ILI9881C_COMMAND_INSTR(0x38, 0x02),
+	ILI9881C_COMMAND_INSTR(0x39, 0x00),
+	ILI9881C_COMMAND_INSTR(0x7A, 0x10), //VLC measure setup
+	// CMD_Page 1
+	ILI9881C_SWITCH_PAGE_INSTR(1),
+	ILI9881C_COMMAND_INSTR(0x22, 0x0E),	//BGR,Normail Black, SS
+	ILI9881C_COMMAND_INSTR(0x2E, 0x88),	//RS[1:0]=01;768x(480+4xNL);NL=136
+	ILI9881C_COMMAND_INSTR(0x31, 0x02),	//00:Column  01:1dot 02:2dot inversion
+	ILI9881C_COMMAND_INSTR(0x52, 0x00),	//VCOM1
+	ILI9881C_COMMAND_INSTR(0x53, 0x1A),	//VCOM1
+	ILI9881C_COMMAND_INSTR(0x54, 0x00),	//VCOM2
+	ILI9881C_COMMAND_INSTR(0x55, 0x1A), //VCOM2
+	ILI9881C_COMMAND_INSTR(0x50, 0x42),	//VREG1OUT=3.504V(0x42)  4V(0x6B)
+	ILI9881C_COMMAND_INSTR(0x51, 0x42), //VREG2OUT=-3.504V0x42)  -4V(0x6B)
+	ILI9881C_COMMAND_INSTR(0x60, 0x1F), //SDT=2.5
+	ILI9881C_COMMAND_INSTR(0x63, 0x00),
+	ILI9881C_COMMAND_INSTR(0xA0, 0x08), //VP255	  0 Gamma P
+	ILI9881C_COMMAND_INSTR(0xA1, 0x20), //VP251   4
+	ILI9881C_COMMAND_INSTR(0xA2, 0x26), //VP247   8
+	ILI9881C_COMMAND_INSTR(0xA3, 0x10), //VP243   12
+	ILI9881C_COMMAND_INSTR(0xA4, 0x10), //VP239   16
+	ILI9881C_COMMAND_INSTR(0xA5, 0x16), //VP231   24      22
+	ILI9881C_COMMAND_INSTR(0xA6, 0x10), //VP219   36      18
+	ILI9881C_COMMAND_INSTR(0xA7, 0x16), //VP203   52      20
+	ILI9881C_COMMAND_INSTR(0xA8, 0x60), //VP175   80
+	ILI9881C_COMMAND_INSTR(0xA9, 0x1C), //VP144   111
+	ILI9881C_COMMAND_INSTR(0xAA, 0x26), //VP111   144
+	ILI9881C_COMMAND_INSTR(0xAB, 0x61), //VP80    175
+	ILI9881C_COMMAND_INSTR(0xAC, 0x28), //VP52    203     1A
+	ILI9881C_COMMAND_INSTR(0xAD, 0x24), //VP36    219     12
+	ILI9881C_COMMAND_INSTR(0xAE, 0x52), //VP24    231
+	ILI9881C_COMMAND_INSTR(0xAF, 0x27), //VP16    239
+	ILI9881C_COMMAND_INSTR(0xB0, 0x2B), //VP12    243
+	ILI9881C_COMMAND_INSTR(0xB1, 0x36), //VP8     247
+	ILI9881C_COMMAND_INSTR(0xB2, 0x63), //VP4     251
+	ILI9881C_COMMAND_INSTR(0xB3, 0x39), //VP0     255
+	ILI9881C_COMMAND_INSTR(0xC0, 0x08), //VN255  0 GAMMA N
+	ILI9881C_COMMAND_INSTR(0xC1, 0x20), //VN251  4
+	ILI9881C_COMMAND_INSTR(0xC2, 0x26), //VN247  8
+	ILI9881C_COMMAND_INSTR(0xC3, 0x10), //VN243  12
+	ILI9881C_COMMAND_INSTR(0xC4, 0x10), //VN239  16
+	ILI9881C_COMMAND_INSTR(0xC5, 0x16), //VN231  24
+	ILI9881C_COMMAND_INSTR(0xC6, 0x10), //VN219  36
+	ILI9881C_COMMAND_INSTR(0xC7, 0x16), //VN203  52
+	ILI9881C_COMMAND_INSTR(0xC8, 0x60), //VN175  80
+	ILI9881C_COMMAND_INSTR(0xC9, 0x1C), //VN144  111
+	ILI9881C_COMMAND_INSTR(0xCA, 0x26), //VN111  144
+	ILI9881C_COMMAND_INSTR(0xCB, 0x61), //VN80   175
+	ILI9881C_COMMAND_INSTR(0xCC, 0x28), //VN52   203
+	ILI9881C_COMMAND_INSTR(0xCD, 0x24), //VN36   219
+	ILI9881C_COMMAND_INSTR(0xCE, 0x52), //VN24   231
+	ILI9881C_COMMAND_INSTR(0xCF, 0x27), //VN16   239
+	ILI9881C_COMMAND_INSTR(0xD0, 0x2B), //VN12   243
+	ILI9881C_COMMAND_INSTR(0xD1, 0x36), //VN8    247
+	ILI9881C_COMMAND_INSTR(0xD2, 0x63), //VN4    251
+	ILI9881C_COMMAND_INSTR(0xD3, 0x39), //VN0    255
+};
+
 static inline struct ili9881c *panel_to_ili9881c(struct drm_panel *panel)
 {
 	return container_of(panel, struct ili9881c, panel);
@@ -1014,6 +1415,40 @@ static const struct drm_display_mode w552946aba_default_mode = {
 	.height_mm	= 121,
 };
 
+static const struct drm_display_mode am_8001280gtzqw_default_mode = {
+	.clock		= 74000,
+
+	.hdisplay	= 800,
+	.hsync_start	= 800 + 100,
+	.hsync_end	= 800 + 100 + 100,
+	.htotal		= 800 + 100 + 100 + 20,
+
+	.vdisplay	= 1280,
+	.vsync_start	= 1280 + 20,
+	.vsync_end	= 1280 + 20 + 16,
+	.vtotal		= 1280 + 20 + 16 + 4,
+
+	.width_mm	= 94,
+	.height_mm	= 151,
+};
+
+static const struct drm_display_mode hsd_p0711t_default_mode = {
+	.clock		= 65500,
+
+	.hdisplay	= 768,
+	.hsync_start	= 768 + 120,
+	.hsync_end	= 768 + 120 + 120,
+	.htotal		= 768 + 120 + 120 + 4,
+
+	.vdisplay	= 1024,
+	.vsync_start	= 1024 + 30,
+	.vsync_end	= 1024 + 30 + 20,
+	.vtotal		= 1024 + 30 + 20 + 4,
+
+	.width_mm	= 119,
+	.height_mm	= 159,
+};
+
 static int ili9881c_get_modes(struct drm_panel *panel,
 			      struct drm_connector *connector)
 {
@@ -1066,6 +1501,7 @@ static int ili9881c_dsi_probe(struct mipi_dsi_device *dsi)
 {
 	struct ili9881c *ctx;
 	int ret;
+	u32 mode_flags;
 
 	ctx = devm_kzalloc(&dsi->dev, sizeof(*ctx), GFP_KERNEL);
 	if (!ctx)
@@ -1100,7 +1536,14 @@ static int ili9881c_dsi_probe(struct mipi_dsi_device *dsi)
 
 	drm_panel_add(&ctx->panel);
 
-	dsi->mode_flags = ctx->desc->mode_flags;
+	if (of_property_read_bool((&dsi->dev)->of_node, "mode-flags")) {
+		ret = of_property_read_u32((&dsi->dev)->of_node, "mode-flags", &mode_flags);
+		if (ret)
+			return ret;
+	}
+
+	dsi->mode_flags = ctx->desc->mode_flags | mode_flags;
+
 	dsi->format = MIPI_DSI_FMT_RGB888;
 	dsi->lanes = 4;
 
@@ -1145,11 +1588,27 @@ static const struct ili9881c_desc w552946aba_desc = {
 		      MIPI_DSI_MODE_LPM | MIPI_DSI_MODE_NO_EOT_PACKET,
 };
 
+static const struct ili9881c_desc am_8001280gtzqw_desc = {
+	.init = am_8001280gtzqw_init,
+	.init_length = ARRAY_SIZE(am_8001280gtzqw_init),
+	.mode = &am_8001280gtzqw_default_mode,
+	.mode_flags = MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+};
+
+static const struct ili9881c_desc hsd_p0711t_desc = {
+	.init = hsd_p0711t_init,
+	.init_length = ARRAY_SIZE(hsd_p0711t_init),
+	.mode = &hsd_p0711t_default_mode,
+	.mode_flags = MIPI_DSI_MODE_VIDEO_HSE | MIPI_DSI_MODE_VIDEO | MIPI_DSI_MODE_LPM | MIPI_DSI_CLOCK_NON_CONTINUOUS | MIPI_DSI_MODE_VIDEO_SYNC_PULSE,
+};
+
 static const struct of_device_id ili9881c_of_match[] = {
 	{ .compatible = "bananapi,lhr050h41", .data = &lhr050h41_desc },
 	{ .compatible = "feixin,k101-im2byl02", .data = &k101_im2byl02_desc },
 	{ .compatible = "tdo,tl050hdv35", .data = &tl050hdv35_desc },
 	{ .compatible = "wanchanglong,w552946aba", .data = &w552946aba_desc },
+	{ .compatible = "ampire,am-8001280gtzqw", .data = &am_8001280gtzqw_desc },
+	{ .compatible = "hsd,p0711t", .data = &hsd_p0711t_desc },
 	{ }
 };
 MODULE_DEVICE_TABLE(of, ili9881c_of_match);
diff --git a/drivers/gpu/drm/panel/panel-lvds.c b/drivers/gpu/drm/panel/panel-lvds.c
index 1b8e3156914c..d57ab96241cb 100644
--- a/drivers/gpu/drm/panel/panel-lvds.c
+++ b/drivers/gpu/drm/panel/panel-lvds.c
@@ -8,6 +8,7 @@
  * Contact: Laurent Pinchart (laurent.pinchart@ideasonboard.com)
  */
 
+#include <linux/delay.h>
 #include <linux/gpio/consumer.h>
 #include <linux/module.h>
 #include <linux/of.h>
@@ -40,6 +41,13 @@ struct panel_lvds {
 	struct gpio_desc *reset_gpio;
 
 	enum drm_panel_orientation orientation;
+
+	bool skip_blpwr_off;
+	unsigned int enable_delay;
+	unsigned int post_prepare_delay;
+	unsigned int pre_disable_delay;
+	unsigned int disable_delay;
+	unsigned int post_unprepare_delay;
 };
 
 static inline struct panel_lvds *to_panel_lvds(struct drm_panel *panel)
@@ -51,11 +59,24 @@ static int panel_lvds_unprepare(struct drm_panel *panel)
 {
 	struct panel_lvds *lvds = to_panel_lvds(panel);
 
+	if (lvds->pre_disable_delay)
+		msleep(lvds->pre_disable_delay);
+
 	if (lvds->enable_gpio)
 		gpiod_set_value_cansleep(lvds->enable_gpio, 0);
 
-	if (lvds->supply)
-		regulator_disable(lvds->supply);
+	if (lvds->disable_delay)
+		msleep(lvds->disable_delay);
+
+	/* if skip_blpwr_off is set, then don't disable supply. Leave it for blpwm to disable.
+	   NOTE: supply regulator must be the same regulator as the blpwm power-supply */
+	if (!lvds->skip_blpwr_off) {
+		if (lvds->supply)
+			regulator_disable(lvds->supply);
+	}
+
+	if (lvds->post_unprepare_delay)
+		msleep(lvds->post_unprepare_delay);
 
 	return 0;
 }
@@ -65,19 +86,28 @@ static int panel_lvds_prepare(struct drm_panel *panel)
 	struct panel_lvds *lvds = to_panel_lvds(panel);
 
 	if (lvds->supply) {
-		int err;
-
-		err = regulator_enable(lvds->supply);
-		if (err < 0) {
-			dev_err(lvds->dev, "failed to enable supply: %d\n",
-				err);
-			return err;
+		/* if skip_blpwr_off is set, then don't enable supply. Leave it for blpwm to enable.
+		   NOTE: supply regulator must be the same regulator as the blpwm power-supply */
+		if (!lvds->skip_blpwr_off) {
+			int err;
+			err = regulator_enable(lvds->supply);
+			if (err < 0) {
+				dev_err(lvds->dev, "failed to enable supply: %d\n",
+					err);
+				return err;
+			}
 		}
 	}
 
+	if (lvds->enable_delay)
+		msleep(lvds->enable_delay);
+
 	if (lvds->enable_gpio)
 		gpiod_set_value_cansleep(lvds->enable_gpio, 1);
 
+	if (lvds->post_prepare_delay)
+		msleep(lvds->post_prepare_delay);
+
 	return 0;
 }
 
@@ -156,6 +186,27 @@ static int panel_lvds_parse_dt(struct panel_lvds *lvds)
 			   DRM_BUS_FLAG_DATA_LSB_TO_MSB :
 			   DRM_BUS_FLAG_DATA_MSB_TO_LSB;
 
+	/*
+	 * These values are optional and set as 0 by default, the out values
+	 * are modified only if a valid u32 value can be decoded.
+	 */
+	lvds->enable_delay = 0;
+	of_property_read_u32(np, "enable-delay-ms",
+			     &lvds->enable_delay);
+	lvds->post_prepare_delay = 0;
+	of_property_read_u32(np, "post-prepare-delay-ms",
+			     &lvds->post_prepare_delay);
+	lvds->pre_disable_delay = 0;
+	of_property_read_u32(np, "pre-disable-delay-ms",
+			     &lvds->pre_disable_delay);
+	lvds->disable_delay = 0;
+	of_property_read_u32(np, "disable-delay-ms",
+			     &lvds->disable_delay);
+	lvds->post_unprepare_delay = 0;
+	of_property_read_u32(np, "post-unprepare-delay-ms",
+			     &lvds->post_unprepare_delay);
+	lvds->skip_blpwr_off = of_property_read_bool(np, "skip-blpwr-off");
+
 	return 0;
 }
 
diff --git a/drivers/gpu/drm/panel/panel-simple.c b/drivers/gpu/drm/panel/panel-simple.c
index 13955e85415b..6d706c0d1b6e 100644
--- a/drivers/gpu/drm/panel/panel-simple.c
+++ b/drivers/gpu/drm/panel/panel-simple.c
@@ -133,6 +133,12 @@ struct panel_desc {
 
 	/** @connector_type: LVDS, eDP, DSI, DPI, etc. */
 	int connector_type;
+
+	/* additional device tree settings for this panel */
+	u32 refresh_rate;
+	u32 rotate;
+	bool hflip;
+	bool vflip;
 };
 
 struct panel_simple {
@@ -187,6 +193,8 @@ static unsigned int panel_simple_get_timings_modes(struct panel_simple *panel,
 		if (panel->desc->num_timings == 1)
 			mode->type |= DRM_MODE_TYPE_PREFERRED;
 
+		drm_mode_debug_printmodeline(mode);
+
 		drm_mode_probed_add(connector, mode);
 		num++;
 	}
@@ -218,6 +226,8 @@ static unsigned int panel_simple_get_display_modes(struct panel_simple *panel,
 
 		drm_mode_set_name(mode);
 
+		drm_mode_debug_printmodeline(mode);
+
 		drm_mode_probed_add(connector, mode);
 		num++;
 	}
@@ -532,16 +542,21 @@ static void panel_simple_parse_panel_timing_node(struct device *dev,
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vactive) ||
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vfront_porch) ||
 		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vback_porch) ||
-		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vsync_len))
+		    !PANEL_SIMPLE_BOUNDS_CHECK(ot, dt, vsync_len)) {
+		        dev_warn(dev, "BOUNDS CHECK failed\n");
 			continue;
+		}
 
-		if (ot->flags != dt->flags)
+		if (ot->flags != dt->flags) {
+			dev_warn(dev, "FLAGS CHECK failed. ot: 0x%x dt:0x%x\n", ot->flags, dt->flags);
 			continue;
+		}
 
 		videomode_from_timing(ot, &vm);
 		drm_display_mode_from_videomode(&vm, &panel->override_mode);
 		panel->override_mode.type |= DRM_MODE_TYPE_DRIVER |
 					     DRM_MODE_TYPE_PREFERRED;
+		dev_warn(dev, "Found suitable override.\n");
 		break;
 	}
 
@@ -549,6 +564,70 @@ static void panel_simple_parse_panel_timing_node(struct device *dev,
 		dev_err(dev, "Reject override mode: No display_timing found\n");
 }
 
+static int panel_simple_parse_dt_settings (struct device *dev, struct panel_simple *panel, const struct panel_desc *desc)
+{
+	struct device_node *np = dev->of_node;
+	struct panel_desc *pd = (struct panel_desc *)desc;
+	int ret = 0; /* return -1 to warn override */
+
+	/* if other panel node attributes exists, parse them from device tree, and force override */
+	if (of_property_read_bool(np, "panel-width-mm")) {
+		of_property_read_u32(np, "panel-width-mm", &pd->size.width);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "panel-height-mm")) {
+		of_property_read_u32(np, "panel-height-mm", &pd->size.height);
+		ret = -1;
+	}
+	/* optional delays */
+	if (of_property_read_bool(np, "delay-prepare")) {
+		of_property_read_u32(np, "delay-prepare", &pd->delay.prepare);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "delay-enable")) {
+		of_property_read_u32(np, "delay-enable", &pd->delay.enable);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "delay-disable")) {
+		of_property_read_u32(np, "delay-disable", &pd->delay.disable);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "delay-unprepare")) {
+		of_property_read_u32(np, "delay-disable", &pd->delay.unprepare);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "refresh-rate")) {
+		of_property_read_u32(np, "refresh-rate", &pd->refresh_rate);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bits-per-color")) {
+		of_property_read_u32(np, "bits-per-color", &pd->bpc);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bus-format")) {
+		of_property_read_u32(np, "bus-format", &pd->bus_format);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "bus-flags")) {
+		of_property_read_u32(np, "bus-flags", &pd->bus_flags);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "rotate")) {
+		of_property_read_u32(np, "rotate", &pd->rotate);
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "horz-flip")) {
+		pd->hflip = true;
+		ret = -1;
+	}
+	if (of_property_read_bool(np, "vert-flip")) {
+		pd->vflip = true;
+		ret = -1;
+	}
+
+	return ret;
+}
+
 static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 {
 	struct panel_simple *panel;
@@ -562,6 +641,11 @@ static int panel_simple_probe(struct device *dev, const struct panel_desc *desc)
 	if (!panel)
 		return -ENOMEM;
 
+	/* force override panel_desc panel settings from dt */
+	err = panel_simple_parse_dt_settings(dev, panel, desc);
+	if (err)
+		dev_warn(dev, "panel-desc setting overridden from dt\n");
+
 	panel->enabled = false;
 	panel->desc = desc;
 
@@ -4880,19 +4964,47 @@ MODULE_DEVICE_TABLE(of, dsi_of_match);
 static int panel_simple_dsi_probe(struct mipi_dsi_device *dsi)
 {
 	const struct panel_desc_dsi *desc;
+	const struct of_device_id *id;
+	struct device_node *np;
+	u32 dsi_flags;
+	u32 dsi_format;
+	u32 dsi_lanes;
 	int err;
 
+	np = dsi->dev.of_node;
 	desc = of_device_get_match_data(&dsi->dev);
-	if (!desc)
-		return -ENODEV;
+	/* if no drm_display_mode from device tree then use the (default) desc (i.e. id->data) */
+	if (!desc) {
+		dsi_flags = desc->flags;
+		dsi_format = desc->format;
+		dsi_lanes = desc->lanes;
+		dev_warn(&dsi->dev, "panel-desc-dsi use default setting\n");
+	} else {
+		/* parse the dsi,flags, format, and lanes setting if set in dt */
+		/* and force override the const static panel_desc_dsi data struct */
+		if (of_property_read_bool(np, "dsi,flags"))
+			of_property_read_u32(np, "dsi,flags", &dsi_flags);
+		if (of_property_read_bool(np, "dsi,format"))
+			of_property_read_u32(np, "dsi,format", &dsi_format);
+		if (of_property_read_bool(np, "dsi,lanes"))
+			of_property_read_u32(np, "dsi,lanes", &dsi_lanes);
+		if (dsi_flags != desc->flags || \
+		    dsi_format != desc->format || \
+		    dsi_lanes !=  desc->lanes) {
+			((struct panel_desc_dsi*)desc)->flags = dsi_flags;
+			((struct panel_desc_dsi*)desc)->format = dsi_format;
+			((struct panel_desc_dsi*)desc)->lanes = dsi_lanes;
+			dev_warn(&dsi->dev, "panel-desc-dsi setting overridden from dt\n");
+		}
+	}
 
 	err = panel_simple_probe(&dsi->dev, &desc->desc);
 	if (err < 0)
 		return err;
 
-	dsi->mode_flags = desc->flags;
-	dsi->format = desc->format;
-	dsi->lanes = desc->lanes;
+	dsi->mode_flags = dsi_flags;
+	dsi->format = dsi_format;
+	dsi->lanes = dsi_lanes;
 
 	err = mipi_dsi_attach(dsi);
 	if (err) {
diff --git a/drivers/net/phy/realtek.c b/drivers/net/phy/realtek.c
index 894172a3e15f..c591af9c4f3d 100644
--- a/drivers/net/phy/realtek.c
+++ b/drivers/net/phy/realtek.c
@@ -73,6 +73,13 @@
 #define RTL_GENERIC_PHYID			0x001cc800
 #define RTL_8211FVD_PHYID			0x001cc878
 
+#define RTL8211F_PAGSEL_LCR				0xd04
+#define RTL8211F_LCR					0x10 /* LED Control Register */
+#define RTL8211F_LCR_LED1_MASK			(BIT(5) | BIT(6) | BIT(8) | BIT(9))
+#define RTL8211F_LCR_LED1_SPEED			(BIT(6) | BIT(8))
+#define RTL8211F_LCR_LED2_MASK			(BIT(10) | BIT(11) | BIT(13) | BIT(14))
+#define RTL8211F_LCR_LED2_LINKACTIVE	        (BIT(10) | BIT(11) | BIT(13) | BIT(14))
+
 MODULE_DESCRIPTION("Realtek PHY driver");
 MODULE_AUTHOR("Johnson Leung");
 MODULE_LICENSE("GPL");
@@ -134,6 +141,22 @@ static int rtl821x_probe(struct phy_device *phydev)
 	return 0;
 }
 
+static void rtl8211f_setup_led(struct phy_device *phydev) {
+	/* By default the EEE LED mode is enabled */
+	/*
+	 * configure led behaviour, LCR Page: 0xd04, Addr: 0x10
+	 * bit [15:8] |xxxx|LED2_ACT|LED2_LINK_1000|xxxx|  |LED2_LINK_100|LED2_LINK_10|LED1_ACT|LED1_LINK_1000|
+	 * bit [7:0]  |xxxx|LED1_LINK_100|LED1_LINK_10|LED0_ACT|  |LED0_LINK_1000|xxxx|LED0_LINK_100|LED0_LINK_10|
+	 * LED2(Y): link/activity, LED1(G): speed
+	 * Yellow = LED2_ACT + LED2_LINK1000 + LED2_LINK100
+	 * Green = LED1_LINK1000 + LED1_LLINK100
+	 */
+	phy_modify_paged_changed(phydev, RTL8211F_PAGSEL_LCR, RTL8211F_LCR,
+					RTL8211F_LCR_LED1_MASK | RTL8211F_LCR_LED1_MASK,
+					RTL8211F_LCR_LED1_SPEED | RTL8211F_LCR_LED2_LINKACTIVE);
+}
+
+
 static int rtl8201_ack_interrupt(struct phy_device *phydev)
 {
 	int err;
@@ -422,6 +445,7 @@ static int rtl8211f_config_init(struct phy_device *phydev)
 			return ret;
 		}
 	}
+        rtl8211f_setup_led(phydev);
 
 	return genphy_soft_reset(phydev);
 }
diff --git a/drivers/usb/dwc3/core.c b/drivers/usb/dwc3/core.c
index b618af020b3b..dd6177714dd2 100644
--- a/drivers/usb/dwc3/core.c
+++ b/drivers/usb/dwc3/core.c
@@ -90,7 +90,8 @@ static int dwc3_get_dr_mode(struct dwc3 *dwc)
 		    (!IS_ENABLED(CONFIG_USB_ROLE_SWITCH) ||
 		     !device_property_read_bool(dwc->dev, "usb-role-switch")) &&
 		    !DWC3_VER_IS_PRIOR(DWC3, 330A))
-			mode = USB_DR_MODE_PERIPHERAL;
+		    /* imx8mp: allow for dual role with no usb-role-switch in dts */
+		    mode = DWC3_VER_IS(DWC3, 330B) ? USB_DR_MODE_OTG : USB_DR_MODE_PERIPHERAL;
 	}
 
 	if (mode != dwc->dr_mode) {
diff --git a/drivers/usb/dwc3/core.h b/drivers/usb/dwc3/core.h
index b5650ebf5d94..cf23d211e56f 100644
--- a/drivers/usb/dwc3/core.h
+++ b/drivers/usb/dwc3/core.h
@@ -1262,6 +1262,7 @@ struct dwc3 {
 #define DWC3_REVISION_300A	0x5533300a
 #define DWC3_REVISION_310A	0x5533310a
 #define DWC3_REVISION_330A	0x5533330a
+#define DWC3_REVISION_330B	0x5533330b
 
 #define DWC31_REVISION_ANY	0x0
 #define DWC31_REVISION_110A	0x3131302a
diff --git a/drivers/video/backlight/pwm_bl.c b/drivers/video/backlight/pwm_bl.c
index ff6eabf8491d..bbc095dc447b 100644
--- a/drivers/video/backlight/pwm_bl.c
+++ b/drivers/video/backlight/pwm_bl.c
@@ -28,8 +28,11 @@ struct pwm_bl_data {
 	struct regulator	*power_supply;
 	struct gpio_desc	*enable_gpio;
 	unsigned int		scale;
+	unsigned int		pre_pwm_on_delay;
 	unsigned int		post_pwm_on_delay;
 	unsigned int		pwm_off_delay;
+	unsigned int		post_pwm_off_delay;
+	bool			skip_blpwr_off;
 	int			(*notify)(struct device *,
 					  int brightness);
 	void			(*notify_after)(struct device *,
@@ -46,6 +49,9 @@ static void pwm_backlight_power_on(struct pwm_bl_data *pb)
 	if (pb->enabled)
 		return;
 
+	if (pb->pre_pwm_on_delay)
+		msleep(pb->pre_pwm_on_delay);
+
 	if (pb->power_supply) {
 		err = regulator_enable(pb->power_supply);
 		if (err < 0)
@@ -70,9 +76,15 @@ static void pwm_backlight_power_off(struct pwm_bl_data *pb)
 	if (pb->pwm_off_delay)
 		msleep(pb->pwm_off_delay);
 
-	if (pb->power_supply)
-		regulator_disable(pb->power_supply);
+	if (!pb->skip_blpwr_off)
+	/* if skip_blpwr_off is set, then don't disable supply. Leave it for lvds-panel to disable.
+	   NOTE: this supply regulator must be set to the lvds0-panel */
+		if (pb->power_supply)
+			regulator_disable(pb->power_supply);
 	pb->enabled = false;
+
+	if (pb->post_pwm_off_delay)
+		msleep(pb->post_pwm_off_delay);
 }
 
 static int compute_duty_cycle(struct pwm_bl_data *pb, int brightness, struct pwm_state *state)
@@ -265,9 +277,14 @@ static int pwm_backlight_parse_dt(struct device *dev,
 	 * These values are optional and set as 0 by default, the out values
 	 * are modified only if a valid u32 value can be decoded.
 	 */
+	of_property_read_u32(node, "pre-pwm-on-delay-ms",
+			     &data->pre_pwm_on_delay);
 	of_property_read_u32(node, "post-pwm-on-delay-ms",
 			     &data->post_pwm_on_delay);
 	of_property_read_u32(node, "pwm-off-delay-ms", &data->pwm_off_delay);
+	of_property_read_u32(node, "post-pwm-off-delay-ms",
+			     &data->post_pwm_off_delay);
+	data->skip_blpwr_off = of_property_read_bool(node, "skip-blpwr-off");
 
 	/*
 	 * Determine the number of brightness levels, if this property is not
@@ -504,8 +521,11 @@ static int pwm_backlight_probe(struct platform_device *pdev)
 	pb->exit = data->exit;
 	pb->dev = &pdev->dev;
 	pb->enabled = false;
+	pb->pre_pwm_on_delay = data->pre_pwm_on_delay;
 	pb->post_pwm_on_delay = data->post_pwm_on_delay;
 	pb->pwm_off_delay = data->pwm_off_delay;
+	pb->post_pwm_off_delay = data->post_pwm_off_delay;
+	pb->skip_blpwr_off = data->skip_blpwr_off;
 	strcpy(pb->fb_id, data->fb_id);
 
 	pb->enable_gpio = devm_gpiod_get_optional(&pdev->dev, "enable",
diff --git a/include/linux/pwm_backlight.h b/include/linux/pwm_backlight.h
index ea3165b7123c..6cf772d8b48a 100644
--- a/include/linux/pwm_backlight.h
+++ b/include/linux/pwm_backlight.h
@@ -13,8 +13,11 @@ struct platform_pwm_backlight_data {
 	unsigned int lth_brightness;
 	unsigned int pwm_period_ns;
 	unsigned int *levels;
+	unsigned int pre_pwm_on_delay;
 	unsigned int post_pwm_on_delay;
 	unsigned int pwm_off_delay;
+	unsigned int post_pwm_off_delay;
+	bool skip_blpwr_off;
 	int (*init)(struct device *dev);
 	int (*notify)(struct device *dev, int brightness);
 	void (*notify_after)(struct device *dev, int brightness);
diff --git a/sound/soc/codecs/sgtl5000.c b/sound/soc/codecs/sgtl5000.c
index b22ba95bd0c0..f0ced5eb4dad 100644
--- a/sound/soc/codecs/sgtl5000.c
+++ b/sound/soc/codecs/sgtl5000.c
@@ -1339,18 +1339,22 @@ static int sgtl5000_set_power_regs(struct snd_soc_component *component)
 					SGTL5000_INT_OSC_EN);
 		/* Enable VDDC charge pump */
 		ana_pwr |= SGTL5000_VDDC_CHRGPMP_POWERUP;
+	} else if (vddio >= 3100 && vdda >= 3100) {
+		/* Disable charge pump */
+		ana_pwr &= ~SGTL5000_VDDC_CHRGPMP_POWERUP;
+
+		/* VDDC use VDDIO rail */
+		lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
+		lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
+				SGTL5000_VDDC_MAN_ASSN_SHIFT;
 	} else {
+		dev_info(component->dev, "SGTL5000 will choose highest voltage automatically!\n");
+
+		/* Disable charge pump */
 		ana_pwr &= ~SGTL5000_VDDC_CHRGPMP_POWERUP;
-		/*
-		 * if vddio == vdda the source of charge pump should be
-		 * assigned manually to VDDIO
-		 */
-		if (regulator_is_equal(sgtl5000->supplies[VDDA].consumer,
-				       sgtl5000->supplies[VDDIO].consumer)) {
-			lreg_ctrl |= SGTL5000_VDDC_ASSN_OVRD;
-			lreg_ctrl |= SGTL5000_VDDC_MAN_ASSN_VDDIO <<
-				    SGTL5000_VDDC_MAN_ASSN_SHIFT;
-		}
+
+		/* Switch to highest supply voltage */
+		lreg_ctrl &= ~SGTL5000_VDDC_ASSN_OVRD;
 	}
 
 	snd_soc_component_write(component, SGTL5000_CHIP_LINREG_CTRL, lreg_ctrl);
